/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package com.cloudera.beeswax.api;

import org.apache.commons.lang.builder.HashCodeBuilder;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;
import org.apache.log4j.Logger;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;

public class BeeswaxService {

  public interface Iface {

    /**
     * Submit a query and return a handle (QueryHandle). The query runs asynchronously.
     * 
     * @param query
     */
    public QueryHandle query(Query query) throws BeeswaxException, TException;

    /**
     * Get the query plan for a query.
     * 
     * @param query
     */
    public QueryExplanation explain(Query query) throws BeeswaxException, TException;

    /**
     * Get the results of a query. This is non-blocking. Caller should check
     * Results.ready to determine if the results are in yet.
     * 
     * @param query_id
     * @param start_over
     */
    public Results fetch(QueryHandle query_id, boolean start_over) throws QueryNotFoundException, BeeswaxException, TException;

    /**
     * Get the state of the query
     * 
     * @param handle
     */
    public int get_state(QueryHandle handle) throws QueryNotFoundException, TException;

    /**
     * Get the result metadata
     * 
     * @param handle
     */
    public ResultsMetadata get_results_metadata(QueryHandle handle) throws QueryNotFoundException, TException;

    /**
     * Used to test connection to server.  A "noop" command.
     * 
     * @param s
     */
    public String echo(String s) throws TException;

    /**
     * Returns a string representation of the configuration object being used.
     * Handy for debugging.
     */
    public String dump_config() throws TException;

    /**
     * Get the log messages related to the given context.
     * 
     * @param context
     */
    public String get_log(String context) throws QueryNotFoundException, TException;

    public List<ConfigVariable> get_default_configuration(boolean include_hadoop) throws TException;

  }

  public static class Client implements Iface {
    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      iprot_ = iprot;
      oprot_ = oprot;
    }

    protected TProtocol iprot_;
    protected TProtocol oprot_;

    protected int seqid_;

    public TProtocol getInputProtocol()
    {
      return this.iprot_;
    }

    public TProtocol getOutputProtocol()
    {
      return this.oprot_;
    }

    public QueryHandle query(Query query) throws BeeswaxException, TException
    {
      send_query(query);
      return recv_query();
    }

    public void send_query(Query query) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("query", TMessageType.CALL, seqid_));
      query_args args = new query_args();
      args.query = query;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public QueryHandle recv_query() throws BeeswaxException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      query_result result = new query_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.error != null) {
        throw result.error;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "query failed: unknown result");
    }

    public QueryExplanation explain(Query query) throws BeeswaxException, TException
    {
      send_explain(query);
      return recv_explain();
    }

    public void send_explain(Query query) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("explain", TMessageType.CALL, seqid_));
      explain_args args = new explain_args();
      args.query = query;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public QueryExplanation recv_explain() throws BeeswaxException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      explain_result result = new explain_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.error != null) {
        throw result.error;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "explain failed: unknown result");
    }

    public Results fetch(QueryHandle query_id, boolean start_over) throws QueryNotFoundException, BeeswaxException, TException
    {
      send_fetch(query_id, start_over);
      return recv_fetch();
    }

    public void send_fetch(QueryHandle query_id, boolean start_over) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("fetch", TMessageType.CALL, seqid_));
      fetch_args args = new fetch_args();
      args.query_id = query_id;
      args.start_over = start_over;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Results recv_fetch() throws QueryNotFoundException, BeeswaxException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      fetch_result result = new fetch_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.error != null) {
        throw result.error;
      }
      if (result.error2 != null) {
        throw result.error2;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "fetch failed: unknown result");
    }

    public int get_state(QueryHandle handle) throws QueryNotFoundException, TException
    {
      send_get_state(handle);
      return recv_get_state();
    }

    public void send_get_state(QueryHandle handle) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_state", TMessageType.CALL, seqid_));
      get_state_args args = new get_state_args();
      args.handle = handle;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public int recv_get_state() throws QueryNotFoundException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_state_result result = new get_state_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.error != null) {
        throw result.error;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_state failed: unknown result");
    }

    public ResultsMetadata get_results_metadata(QueryHandle handle) throws QueryNotFoundException, TException
    {
      send_get_results_metadata(handle);
      return recv_get_results_metadata();
    }

    public void send_get_results_metadata(QueryHandle handle) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_results_metadata", TMessageType.CALL, seqid_));
      get_results_metadata_args args = new get_results_metadata_args();
      args.handle = handle;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public ResultsMetadata recv_get_results_metadata() throws QueryNotFoundException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_results_metadata_result result = new get_results_metadata_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.error != null) {
        throw result.error;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_results_metadata failed: unknown result");
    }

    public String echo(String s) throws TException
    {
      send_echo(s);
      return recv_echo();
    }

    public void send_echo(String s) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("echo", TMessageType.CALL, seqid_));
      echo_args args = new echo_args();
      args.s = s;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public String recv_echo() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      echo_result result = new echo_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "echo failed: unknown result");
    }

    public String dump_config() throws TException
    {
      send_dump_config();
      return recv_dump_config();
    }

    public void send_dump_config() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("dump_config", TMessageType.CALL, seqid_));
      dump_config_args args = new dump_config_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public String recv_dump_config() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dump_config_result result = new dump_config_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dump_config failed: unknown result");
    }

    public String get_log(String context) throws QueryNotFoundException, TException
    {
      send_get_log(context);
      return recv_get_log();
    }

    public void send_get_log(String context) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_log", TMessageType.CALL, seqid_));
      get_log_args args = new get_log_args();
      args.context = context;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public String recv_get_log() throws QueryNotFoundException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_log_result result = new get_log_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.error != null) {
        throw result.error;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_log failed: unknown result");
    }

    public List<ConfigVariable> get_default_configuration(boolean include_hadoop) throws TException
    {
      send_get_default_configuration(include_hadoop);
      return recv_get_default_configuration();
    }

    public void send_get_default_configuration(boolean include_hadoop) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_default_configuration", TMessageType.CALL, seqid_));
      get_default_configuration_args args = new get_default_configuration_args();
      args.include_hadoop = include_hadoop;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<ConfigVariable> recv_get_default_configuration() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_default_configuration_result result = new get_default_configuration_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_default_configuration failed: unknown result");
    }

  }
  public static class Processor implements TProcessor {
    private static final Logger LOGGER = Logger.getLogger(Processor.class.getName());
    public Processor(Iface iface)
    {
      iface_ = iface;
      processMap_.put("query", new query());
      processMap_.put("explain", new explain());
      processMap_.put("fetch", new fetch());
      processMap_.put("get_state", new get_state());
      processMap_.put("get_results_metadata", new get_results_metadata());
      processMap_.put("echo", new echo());
      processMap_.put("dump_config", new dump_config());
      processMap_.put("get_log", new get_log());
      processMap_.put("get_default_configuration", new get_default_configuration());
    }

    protected static interface ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
    }

    private Iface iface_;
    protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();

    public boolean process(TProtocol iprot, TProtocol oprot) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot);
      return true;
    }

    private class query implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        query_args args = new query_args();
        args.read(iprot);
        iprot.readMessageEnd();
        query_result result = new query_result();
        try {
          result.success = iface_.query(args.query);
        } catch (BeeswaxException error) {
          result.error = error;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing query", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing query");
          oprot.writeMessageBegin(new TMessage("query", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("query", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class explain implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        explain_args args = new explain_args();
        args.read(iprot);
        iprot.readMessageEnd();
        explain_result result = new explain_result();
        try {
          result.success = iface_.explain(args.query);
        } catch (BeeswaxException error) {
          result.error = error;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing explain", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing explain");
          oprot.writeMessageBegin(new TMessage("explain", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("explain", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class fetch implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        fetch_args args = new fetch_args();
        args.read(iprot);
        iprot.readMessageEnd();
        fetch_result result = new fetch_result();
        try {
          result.success = iface_.fetch(args.query_id, args.start_over);
        } catch (QueryNotFoundException error) {
          result.error = error;
        } catch (BeeswaxException error2) {
          result.error2 = error2;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing fetch", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing fetch");
          oprot.writeMessageBegin(new TMessage("fetch", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("fetch", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_state implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_state_args args = new get_state_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_state_result result = new get_state_result();
        try {
          result.success = iface_.get_state(args.handle);
          result.__isset.success = true;
        } catch (QueryNotFoundException error) {
          result.error = error;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_state", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_state");
          oprot.writeMessageBegin(new TMessage("get_state", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_state", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_results_metadata implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_results_metadata_args args = new get_results_metadata_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_results_metadata_result result = new get_results_metadata_result();
        try {
          result.success = iface_.get_results_metadata(args.handle);
        } catch (QueryNotFoundException error) {
          result.error = error;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_results_metadata", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_results_metadata");
          oprot.writeMessageBegin(new TMessage("get_results_metadata", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_results_metadata", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class echo implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        echo_args args = new echo_args();
        args.read(iprot);
        iprot.readMessageEnd();
        echo_result result = new echo_result();
        result.success = iface_.echo(args.s);
        oprot.writeMessageBegin(new TMessage("echo", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class dump_config implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        dump_config_args args = new dump_config_args();
        args.read(iprot);
        iprot.readMessageEnd();
        dump_config_result result = new dump_config_result();
        result.success = iface_.dump_config();
        oprot.writeMessageBegin(new TMessage("dump_config", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_log implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_log_args args = new get_log_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_log_result result = new get_log_result();
        try {
          result.success = iface_.get_log(args.context);
        } catch (QueryNotFoundException error) {
          result.error = error;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get_log", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_log");
          oprot.writeMessageBegin(new TMessage("get_log", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get_log", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_default_configuration implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_default_configuration_args args = new get_default_configuration_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_default_configuration_result result = new get_default_configuration_result();
        result.success = iface_.get_default_configuration(args.include_hadoop);
        oprot.writeMessageBegin(new TMessage("get_default_configuration", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

  }

  public static class query_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("query_args");
    private static final TField QUERY_FIELD_DESC = new TField("query", TType.STRUCT, (short)1);

    public Query query;
    public static final int QUERY = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(QUERY, new FieldMetaData("query", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Query.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(query_args.class, metaDataMap);
    }

    public query_args() {
    }

    public query_args(
      Query query)
    {
      this();
      this.query = query;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public query_args(query_args other) {
      if (other.isSetQuery()) {
        this.query = new Query(other.query);
      }
    }

    @Override
    public query_args clone() {
      return new query_args(this);
    }

    public Query getQuery() {
      return this.query;
    }

    public void setQuery(Query query) {
      this.query = query;
    }

    public void unsetQuery() {
      this.query = null;
    }

    // Returns true if field query is set (has been asigned a value) and false otherwise
    public boolean isSetQuery() {
      return this.query != null;
    }

    public void setQueryIsSet(boolean value) {
      if (!value) {
        this.query = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case QUERY:
        if (value == null) {
          unsetQuery();
        } else {
          setQuery((Query)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case QUERY:
        return getQuery();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case QUERY:
        return isSetQuery();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof query_args)
        return this.equals((query_args)that);
      return false;
    }

    public boolean equals(query_args that) {
      if (that == null)
        return false;

      boolean this_present_query = true && this.isSetQuery();
      boolean that_present_query = true && that.isSetQuery();
      if (this_present_query || that_present_query) {
        if (!(this_present_query && that_present_query))
          return false;
        if (!this.query.equals(that.query))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_query = true && (isSetQuery());
      builder.append(present_query);
      if (present_query)
        builder.append(query);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case QUERY:
            if (field.type == TType.STRUCT) {
              this.query = new Query();
              this.query.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.query != null) {
        oprot.writeFieldBegin(QUERY_FIELD_DESC);
        this.query.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("query_args(");
      boolean first = true;

      sb.append("query:");
      if (this.query == null) {
        sb.append("null");
      } else {
        sb.append(this.query);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class query_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("query_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField ERROR_FIELD_DESC = new TField("error", TType.STRUCT, (short)1);

    public QueryHandle success;
    public static final int SUCCESS = 0;
    public BeeswaxException error;
    public static final int ERROR = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, QueryHandle.class)));
      put(ERROR, new FieldMetaData("error", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(query_result.class, metaDataMap);
    }

    public query_result() {
    }

    public query_result(
      QueryHandle success,
      BeeswaxException error)
    {
      this();
      this.success = success;
      this.error = error;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public query_result(query_result other) {
      if (other.isSetSuccess()) {
        this.success = new QueryHandle(other.success);
      }
      if (other.isSetError()) {
        this.error = new BeeswaxException(other.error);
      }
    }

    @Override
    public query_result clone() {
      return new query_result(this);
    }

    public QueryHandle getSuccess() {
      return this.success;
    }

    public void setSuccess(QueryHandle success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public BeeswaxException getError() {
      return this.error;
    }

    public void setError(BeeswaxException error) {
      this.error = error;
    }

    public void unsetError() {
      this.error = null;
    }

    // Returns true if field error is set (has been asigned a value) and false otherwise
    public boolean isSetError() {
      return this.error != null;
    }

    public void setErrorIsSet(boolean value) {
      if (!value) {
        this.error = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((QueryHandle)value);
        }
        break;

      case ERROR:
        if (value == null) {
          unsetError();
        } else {
          setError((BeeswaxException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case ERROR:
        return getError();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case ERROR:
        return isSetError();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof query_result)
        return this.equals((query_result)that);
      return false;
    }

    public boolean equals(query_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_error = true && this.isSetError();
      boolean that_present_error = true && that.isSetError();
      if (this_present_error || that_present_error) {
        if (!(this_present_error && that_present_error))
          return false;
        if (!this.error.equals(that.error))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      boolean present_error = true && (isSetError());
      builder.append(present_error);
      if (present_error)
        builder.append(error);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new QueryHandle();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case ERROR:
            if (field.type == TType.STRUCT) {
              this.error = new BeeswaxException();
              this.error.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetError()) {
        oprot.writeFieldBegin(ERROR_FIELD_DESC);
        this.error.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("query_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("error:");
      if (this.error == null) {
        sb.append("null");
      } else {
        sb.append(this.error);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class explain_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("explain_args");
    private static final TField QUERY_FIELD_DESC = new TField("query", TType.STRUCT, (short)1);

    public Query query;
    public static final int QUERY = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(QUERY, new FieldMetaData("query", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Query.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(explain_args.class, metaDataMap);
    }

    public explain_args() {
    }

    public explain_args(
      Query query)
    {
      this();
      this.query = query;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public explain_args(explain_args other) {
      if (other.isSetQuery()) {
        this.query = new Query(other.query);
      }
    }

    @Override
    public explain_args clone() {
      return new explain_args(this);
    }

    public Query getQuery() {
      return this.query;
    }

    public void setQuery(Query query) {
      this.query = query;
    }

    public void unsetQuery() {
      this.query = null;
    }

    // Returns true if field query is set (has been asigned a value) and false otherwise
    public boolean isSetQuery() {
      return this.query != null;
    }

    public void setQueryIsSet(boolean value) {
      if (!value) {
        this.query = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case QUERY:
        if (value == null) {
          unsetQuery();
        } else {
          setQuery((Query)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case QUERY:
        return getQuery();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case QUERY:
        return isSetQuery();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof explain_args)
        return this.equals((explain_args)that);
      return false;
    }

    public boolean equals(explain_args that) {
      if (that == null)
        return false;

      boolean this_present_query = true && this.isSetQuery();
      boolean that_present_query = true && that.isSetQuery();
      if (this_present_query || that_present_query) {
        if (!(this_present_query && that_present_query))
          return false;
        if (!this.query.equals(that.query))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_query = true && (isSetQuery());
      builder.append(present_query);
      if (present_query)
        builder.append(query);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case QUERY:
            if (field.type == TType.STRUCT) {
              this.query = new Query();
              this.query.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.query != null) {
        oprot.writeFieldBegin(QUERY_FIELD_DESC);
        this.query.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("explain_args(");
      boolean first = true;

      sb.append("query:");
      if (this.query == null) {
        sb.append("null");
      } else {
        sb.append(this.query);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class explain_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("explain_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField ERROR_FIELD_DESC = new TField("error", TType.STRUCT, (short)1);

    public QueryExplanation success;
    public static final int SUCCESS = 0;
    public BeeswaxException error;
    public static final int ERROR = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, QueryExplanation.class)));
      put(ERROR, new FieldMetaData("error", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(explain_result.class, metaDataMap);
    }

    public explain_result() {
    }

    public explain_result(
      QueryExplanation success,
      BeeswaxException error)
    {
      this();
      this.success = success;
      this.error = error;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public explain_result(explain_result other) {
      if (other.isSetSuccess()) {
        this.success = new QueryExplanation(other.success);
      }
      if (other.isSetError()) {
        this.error = new BeeswaxException(other.error);
      }
    }

    @Override
    public explain_result clone() {
      return new explain_result(this);
    }

    public QueryExplanation getSuccess() {
      return this.success;
    }

    public void setSuccess(QueryExplanation success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public BeeswaxException getError() {
      return this.error;
    }

    public void setError(BeeswaxException error) {
      this.error = error;
    }

    public void unsetError() {
      this.error = null;
    }

    // Returns true if field error is set (has been asigned a value) and false otherwise
    public boolean isSetError() {
      return this.error != null;
    }

    public void setErrorIsSet(boolean value) {
      if (!value) {
        this.error = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((QueryExplanation)value);
        }
        break;

      case ERROR:
        if (value == null) {
          unsetError();
        } else {
          setError((BeeswaxException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case ERROR:
        return getError();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case ERROR:
        return isSetError();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof explain_result)
        return this.equals((explain_result)that);
      return false;
    }

    public boolean equals(explain_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_error = true && this.isSetError();
      boolean that_present_error = true && that.isSetError();
      if (this_present_error || that_present_error) {
        if (!(this_present_error && that_present_error))
          return false;
        if (!this.error.equals(that.error))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      boolean present_error = true && (isSetError());
      builder.append(present_error);
      if (present_error)
        builder.append(error);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new QueryExplanation();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case ERROR:
            if (field.type == TType.STRUCT) {
              this.error = new BeeswaxException();
              this.error.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetError()) {
        oprot.writeFieldBegin(ERROR_FIELD_DESC);
        this.error.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("explain_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("error:");
      if (this.error == null) {
        sb.append("null");
      } else {
        sb.append(this.error);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class fetch_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("fetch_args");
    private static final TField QUERY_ID_FIELD_DESC = new TField("query_id", TType.STRUCT, (short)1);
    private static final TField START_OVER_FIELD_DESC = new TField("start_over", TType.BOOL, (short)2);

    public QueryHandle query_id;
    public static final int QUERY_ID = 1;
    public boolean start_over;
    public static final int START_OVER = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean start_over = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(QUERY_ID, new FieldMetaData("query_id", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, QueryHandle.class)));
      put(START_OVER, new FieldMetaData("start_over", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(fetch_args.class, metaDataMap);
    }

    public fetch_args() {
    }

    public fetch_args(
      QueryHandle query_id,
      boolean start_over)
    {
      this();
      this.query_id = query_id;
      this.start_over = start_over;
      this.__isset.start_over = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public fetch_args(fetch_args other) {
      if (other.isSetQuery_id()) {
        this.query_id = new QueryHandle(other.query_id);
      }
      __isset.start_over = other.__isset.start_over;
      this.start_over = other.start_over;
    }

    @Override
    public fetch_args clone() {
      return new fetch_args(this);
    }

    public QueryHandle getQuery_id() {
      return this.query_id;
    }

    public void setQuery_id(QueryHandle query_id) {
      this.query_id = query_id;
    }

    public void unsetQuery_id() {
      this.query_id = null;
    }

    // Returns true if field query_id is set (has been asigned a value) and false otherwise
    public boolean isSetQuery_id() {
      return this.query_id != null;
    }

    public void setQuery_idIsSet(boolean value) {
      if (!value) {
        this.query_id = null;
      }
    }

    public boolean isStart_over() {
      return this.start_over;
    }

    public void setStart_over(boolean start_over) {
      this.start_over = start_over;
      this.__isset.start_over = true;
    }

    public void unsetStart_over() {
      this.__isset.start_over = false;
    }

    // Returns true if field start_over is set (has been asigned a value) and false otherwise
    public boolean isSetStart_over() {
      return this.__isset.start_over;
    }

    public void setStart_overIsSet(boolean value) {
      this.__isset.start_over = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case QUERY_ID:
        if (value == null) {
          unsetQuery_id();
        } else {
          setQuery_id((QueryHandle)value);
        }
        break;

      case START_OVER:
        if (value == null) {
          unsetStart_over();
        } else {
          setStart_over((Boolean)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case QUERY_ID:
        return getQuery_id();

      case START_OVER:
        return new Boolean(isStart_over());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case QUERY_ID:
        return isSetQuery_id();
      case START_OVER:
        return isSetStart_over();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof fetch_args)
        return this.equals((fetch_args)that);
      return false;
    }

    public boolean equals(fetch_args that) {
      if (that == null)
        return false;

      boolean this_present_query_id = true && this.isSetQuery_id();
      boolean that_present_query_id = true && that.isSetQuery_id();
      if (this_present_query_id || that_present_query_id) {
        if (!(this_present_query_id && that_present_query_id))
          return false;
        if (!this.query_id.equals(that.query_id))
          return false;
      }

      boolean this_present_start_over = true;
      boolean that_present_start_over = true;
      if (this_present_start_over || that_present_start_over) {
        if (!(this_present_start_over && that_present_start_over))
          return false;
        if (this.start_over != that.start_over)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_query_id = true && (isSetQuery_id());
      builder.append(present_query_id);
      if (present_query_id)
        builder.append(query_id);

      boolean present_start_over = true;
      builder.append(present_start_over);
      if (present_start_over)
        builder.append(start_over);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case QUERY_ID:
            if (field.type == TType.STRUCT) {
              this.query_id = new QueryHandle();
              this.query_id.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case START_OVER:
            if (field.type == TType.BOOL) {
              this.start_over = iprot.readBool();
              this.__isset.start_over = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.query_id != null) {
        oprot.writeFieldBegin(QUERY_ID_FIELD_DESC);
        this.query_id.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(START_OVER_FIELD_DESC);
      oprot.writeBool(this.start_over);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("fetch_args(");
      boolean first = true;

      sb.append("query_id:");
      if (this.query_id == null) {
        sb.append("null");
      } else {
        sb.append(this.query_id);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("start_over:");
      sb.append(this.start_over);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class fetch_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("fetch_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField ERROR_FIELD_DESC = new TField("error", TType.STRUCT, (short)1);
    private static final TField ERROR2_FIELD_DESC = new TField("error2", TType.STRUCT, (short)2);

    public Results success;
    public static final int SUCCESS = 0;
    public QueryNotFoundException error;
    public static final int ERROR = 1;
    public BeeswaxException error2;
    public static final int ERROR2 = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Results.class)));
      put(ERROR, new FieldMetaData("error", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(ERROR2, new FieldMetaData("error2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(fetch_result.class, metaDataMap);
    }

    public fetch_result() {
    }

    public fetch_result(
      Results success,
      QueryNotFoundException error,
      BeeswaxException error2)
    {
      this();
      this.success = success;
      this.error = error;
      this.error2 = error2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public fetch_result(fetch_result other) {
      if (other.isSetSuccess()) {
        this.success = new Results(other.success);
      }
      if (other.isSetError()) {
        this.error = new QueryNotFoundException(other.error);
      }
      if (other.isSetError2()) {
        this.error2 = new BeeswaxException(other.error2);
      }
    }

    @Override
    public fetch_result clone() {
      return new fetch_result(this);
    }

    public Results getSuccess() {
      return this.success;
    }

    public void setSuccess(Results success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public QueryNotFoundException getError() {
      return this.error;
    }

    public void setError(QueryNotFoundException error) {
      this.error = error;
    }

    public void unsetError() {
      this.error = null;
    }

    // Returns true if field error is set (has been asigned a value) and false otherwise
    public boolean isSetError() {
      return this.error != null;
    }

    public void setErrorIsSet(boolean value) {
      if (!value) {
        this.error = null;
      }
    }

    public BeeswaxException getError2() {
      return this.error2;
    }

    public void setError2(BeeswaxException error2) {
      this.error2 = error2;
    }

    public void unsetError2() {
      this.error2 = null;
    }

    // Returns true if field error2 is set (has been asigned a value) and false otherwise
    public boolean isSetError2() {
      return this.error2 != null;
    }

    public void setError2IsSet(boolean value) {
      if (!value) {
        this.error2 = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Results)value);
        }
        break;

      case ERROR:
        if (value == null) {
          unsetError();
        } else {
          setError((QueryNotFoundException)value);
        }
        break;

      case ERROR2:
        if (value == null) {
          unsetError2();
        } else {
          setError2((BeeswaxException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case ERROR:
        return getError();

      case ERROR2:
        return getError2();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case ERROR:
        return isSetError();
      case ERROR2:
        return isSetError2();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof fetch_result)
        return this.equals((fetch_result)that);
      return false;
    }

    public boolean equals(fetch_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_error = true && this.isSetError();
      boolean that_present_error = true && that.isSetError();
      if (this_present_error || that_present_error) {
        if (!(this_present_error && that_present_error))
          return false;
        if (!this.error.equals(that.error))
          return false;
      }

      boolean this_present_error2 = true && this.isSetError2();
      boolean that_present_error2 = true && that.isSetError2();
      if (this_present_error2 || that_present_error2) {
        if (!(this_present_error2 && that_present_error2))
          return false;
        if (!this.error2.equals(that.error2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      boolean present_error = true && (isSetError());
      builder.append(present_error);
      if (present_error)
        builder.append(error);

      boolean present_error2 = true && (isSetError2());
      builder.append(present_error2);
      if (present_error2)
        builder.append(error2);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new Results();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case ERROR:
            if (field.type == TType.STRUCT) {
              this.error = new QueryNotFoundException();
              this.error.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case ERROR2:
            if (field.type == TType.STRUCT) {
              this.error2 = new BeeswaxException();
              this.error2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetError()) {
        oprot.writeFieldBegin(ERROR_FIELD_DESC);
        this.error.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetError2()) {
        oprot.writeFieldBegin(ERROR2_FIELD_DESC);
        this.error2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("fetch_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("error:");
      if (this.error == null) {
        sb.append("null");
      } else {
        sb.append(this.error);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("error2:");
      if (this.error2 == null) {
        sb.append("null");
      } else {
        sb.append(this.error2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_state_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_state_args");
    private static final TField HANDLE_FIELD_DESC = new TField("handle", TType.STRUCT, (short)1);

    public QueryHandle handle;
    public static final int HANDLE = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(HANDLE, new FieldMetaData("handle", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, QueryHandle.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_state_args.class, metaDataMap);
    }

    public get_state_args() {
    }

    public get_state_args(
      QueryHandle handle)
    {
      this();
      this.handle = handle;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_state_args(get_state_args other) {
      if (other.isSetHandle()) {
        this.handle = new QueryHandle(other.handle);
      }
    }

    @Override
    public get_state_args clone() {
      return new get_state_args(this);
    }

    public QueryHandle getHandle() {
      return this.handle;
    }

    public void setHandle(QueryHandle handle) {
      this.handle = handle;
    }

    public void unsetHandle() {
      this.handle = null;
    }

    // Returns true if field handle is set (has been asigned a value) and false otherwise
    public boolean isSetHandle() {
      return this.handle != null;
    }

    public void setHandleIsSet(boolean value) {
      if (!value) {
        this.handle = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case HANDLE:
        if (value == null) {
          unsetHandle();
        } else {
          setHandle((QueryHandle)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case HANDLE:
        return getHandle();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case HANDLE:
        return isSetHandle();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_state_args)
        return this.equals((get_state_args)that);
      return false;
    }

    public boolean equals(get_state_args that) {
      if (that == null)
        return false;

      boolean this_present_handle = true && this.isSetHandle();
      boolean that_present_handle = true && that.isSetHandle();
      if (this_present_handle || that_present_handle) {
        if (!(this_present_handle && that_present_handle))
          return false;
        if (!this.handle.equals(that.handle))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_handle = true && (isSetHandle());
      builder.append(present_handle);
      if (present_handle)
        builder.append(handle);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case HANDLE:
            if (field.type == TType.STRUCT) {
              this.handle = new QueryHandle();
              this.handle.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.handle != null) {
        oprot.writeFieldBegin(HANDLE_FIELD_DESC);
        this.handle.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_state_args(");
      boolean first = true;

      sb.append("handle:");
      if (this.handle == null) {
        sb.append("null");
      } else {
        sb.append(this.handle);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_state_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_state_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I32, (short)0);
    private static final TField ERROR_FIELD_DESC = new TField("error", TType.STRUCT, (short)1);

    public int success;
    public static final int SUCCESS = 0;
    public QueryNotFoundException error;
    public static final int ERROR = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
      put(ERROR, new FieldMetaData("error", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_state_result.class, metaDataMap);
    }

    public get_state_result() {
    }

    public get_state_result(
      int success,
      QueryNotFoundException error)
    {
      this();
      this.success = success;
      this.__isset.success = true;
      this.error = error;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_state_result(get_state_result other) {
      __isset.success = other.__isset.success;
      this.success = other.success;
      if (other.isSetError()) {
        this.error = new QueryNotFoundException(other.error);
      }
    }

    @Override
    public get_state_result clone() {
      return new get_state_result(this);
    }

    public int getSuccess() {
      return this.success;
    }

    public void setSuccess(int success) {
      this.success = success;
      this.__isset.success = true;
    }

    public void unsetSuccess() {
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public QueryNotFoundException getError() {
      return this.error;
    }

    public void setError(QueryNotFoundException error) {
      this.error = error;
    }

    public void unsetError() {
      this.error = null;
    }

    // Returns true if field error is set (has been asigned a value) and false otherwise
    public boolean isSetError() {
      return this.error != null;
    }

    public void setErrorIsSet(boolean value) {
      if (!value) {
        this.error = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Integer)value);
        }
        break;

      case ERROR:
        if (value == null) {
          unsetError();
        } else {
          setError((QueryNotFoundException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case ERROR:
        return getError();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case ERROR:
        return isSetError();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_state_result)
        return this.equals((get_state_result)that);
      return false;
    }

    public boolean equals(get_state_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_error = true && this.isSetError();
      boolean that_present_error = true && that.isSetError();
      if (this_present_error || that_present_error) {
        if (!(this_present_error && that_present_error))
          return false;
        if (!this.error.equals(that.error))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true;
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      boolean present_error = true && (isSetError());
      builder.append(present_error);
      if (present_error)
        builder.append(error);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.I32) {
              this.success = iprot.readI32();
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case ERROR:
            if (field.type == TType.STRUCT) {
              this.error = new QueryNotFoundException();
              this.error.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI32(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetError()) {
        oprot.writeFieldBegin(ERROR_FIELD_DESC);
        this.error.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_state_result(");
      boolean first = true;

      sb.append("success:");
      String success_name = QueryState.VALUES_TO_NAMES.get(this.success);
      if (success_name != null) {
        sb.append(success_name);
        sb.append(" (");
      }
      sb.append(this.success);
      if (success_name != null) {
        sb.append(")");
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("error:");
      if (this.error == null) {
        sb.append("null");
      } else {
        sb.append(this.error);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
      if (isSetSuccess() && !QueryState.VALID_VALUES.contains(success)){
        throw new TProtocolException("The field 'success' has been assigned the invalid value " + success);
      }
    }

  }

  public static class get_results_metadata_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_results_metadata_args");
    private static final TField HANDLE_FIELD_DESC = new TField("handle", TType.STRUCT, (short)1);

    public QueryHandle handle;
    public static final int HANDLE = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(HANDLE, new FieldMetaData("handle", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, QueryHandle.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_results_metadata_args.class, metaDataMap);
    }

    public get_results_metadata_args() {
    }

    public get_results_metadata_args(
      QueryHandle handle)
    {
      this();
      this.handle = handle;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_results_metadata_args(get_results_metadata_args other) {
      if (other.isSetHandle()) {
        this.handle = new QueryHandle(other.handle);
      }
    }

    @Override
    public get_results_metadata_args clone() {
      return new get_results_metadata_args(this);
    }

    public QueryHandle getHandle() {
      return this.handle;
    }

    public void setHandle(QueryHandle handle) {
      this.handle = handle;
    }

    public void unsetHandle() {
      this.handle = null;
    }

    // Returns true if field handle is set (has been asigned a value) and false otherwise
    public boolean isSetHandle() {
      return this.handle != null;
    }

    public void setHandleIsSet(boolean value) {
      if (!value) {
        this.handle = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case HANDLE:
        if (value == null) {
          unsetHandle();
        } else {
          setHandle((QueryHandle)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case HANDLE:
        return getHandle();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case HANDLE:
        return isSetHandle();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_results_metadata_args)
        return this.equals((get_results_metadata_args)that);
      return false;
    }

    public boolean equals(get_results_metadata_args that) {
      if (that == null)
        return false;

      boolean this_present_handle = true && this.isSetHandle();
      boolean that_present_handle = true && that.isSetHandle();
      if (this_present_handle || that_present_handle) {
        if (!(this_present_handle && that_present_handle))
          return false;
        if (!this.handle.equals(that.handle))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_handle = true && (isSetHandle());
      builder.append(present_handle);
      if (present_handle)
        builder.append(handle);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case HANDLE:
            if (field.type == TType.STRUCT) {
              this.handle = new QueryHandle();
              this.handle.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.handle != null) {
        oprot.writeFieldBegin(HANDLE_FIELD_DESC);
        this.handle.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_results_metadata_args(");
      boolean first = true;

      sb.append("handle:");
      if (this.handle == null) {
        sb.append("null");
      } else {
        sb.append(this.handle);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_results_metadata_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_results_metadata_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField ERROR_FIELD_DESC = new TField("error", TType.STRUCT, (short)1);

    public ResultsMetadata success;
    public static final int SUCCESS = 0;
    public QueryNotFoundException error;
    public static final int ERROR = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, ResultsMetadata.class)));
      put(ERROR, new FieldMetaData("error", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_results_metadata_result.class, metaDataMap);
    }

    public get_results_metadata_result() {
    }

    public get_results_metadata_result(
      ResultsMetadata success,
      QueryNotFoundException error)
    {
      this();
      this.success = success;
      this.error = error;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_results_metadata_result(get_results_metadata_result other) {
      if (other.isSetSuccess()) {
        this.success = new ResultsMetadata(other.success);
      }
      if (other.isSetError()) {
        this.error = new QueryNotFoundException(other.error);
      }
    }

    @Override
    public get_results_metadata_result clone() {
      return new get_results_metadata_result(this);
    }

    public ResultsMetadata getSuccess() {
      return this.success;
    }

    public void setSuccess(ResultsMetadata success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public QueryNotFoundException getError() {
      return this.error;
    }

    public void setError(QueryNotFoundException error) {
      this.error = error;
    }

    public void unsetError() {
      this.error = null;
    }

    // Returns true if field error is set (has been asigned a value) and false otherwise
    public boolean isSetError() {
      return this.error != null;
    }

    public void setErrorIsSet(boolean value) {
      if (!value) {
        this.error = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((ResultsMetadata)value);
        }
        break;

      case ERROR:
        if (value == null) {
          unsetError();
        } else {
          setError((QueryNotFoundException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case ERROR:
        return getError();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case ERROR:
        return isSetError();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_results_metadata_result)
        return this.equals((get_results_metadata_result)that);
      return false;
    }

    public boolean equals(get_results_metadata_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_error = true && this.isSetError();
      boolean that_present_error = true && that.isSetError();
      if (this_present_error || that_present_error) {
        if (!(this_present_error && that_present_error))
          return false;
        if (!this.error.equals(that.error))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      boolean present_error = true && (isSetError());
      builder.append(present_error);
      if (present_error)
        builder.append(error);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new ResultsMetadata();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case ERROR:
            if (field.type == TType.STRUCT) {
              this.error = new QueryNotFoundException();
              this.error.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetError()) {
        oprot.writeFieldBegin(ERROR_FIELD_DESC);
        this.error.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_results_metadata_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("error:");
      if (this.error == null) {
        sb.append("null");
      } else {
        sb.append(this.error);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class echo_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("echo_args");
    private static final TField S_FIELD_DESC = new TField("s", TType.STRING, (short)1);

    public String s;
    public static final int S = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(S, new FieldMetaData("s", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(echo_args.class, metaDataMap);
    }

    public echo_args() {
    }

    public echo_args(
      String s)
    {
      this();
      this.s = s;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public echo_args(echo_args other) {
      if (other.isSetS()) {
        this.s = other.s;
      }
    }

    @Override
    public echo_args clone() {
      return new echo_args(this);
    }

    public String getS() {
      return this.s;
    }

    public void setS(String s) {
      this.s = s;
    }

    public void unsetS() {
      this.s = null;
    }

    // Returns true if field s is set (has been asigned a value) and false otherwise
    public boolean isSetS() {
      return this.s != null;
    }

    public void setSIsSet(boolean value) {
      if (!value) {
        this.s = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case S:
        if (value == null) {
          unsetS();
        } else {
          setS((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case S:
        return getS();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case S:
        return isSetS();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof echo_args)
        return this.equals((echo_args)that);
      return false;
    }

    public boolean equals(echo_args that) {
      if (that == null)
        return false;

      boolean this_present_s = true && this.isSetS();
      boolean that_present_s = true && that.isSetS();
      if (this_present_s || that_present_s) {
        if (!(this_present_s && that_present_s))
          return false;
        if (!this.s.equals(that.s))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_s = true && (isSetS());
      builder.append(present_s);
      if (present_s)
        builder.append(s);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case S:
            if (field.type == TType.STRING) {
              this.s = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.s != null) {
        oprot.writeFieldBegin(S_FIELD_DESC);
        oprot.writeString(this.s);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("echo_args(");
      boolean first = true;

      sb.append("s:");
      if (this.s == null) {
        sb.append("null");
      } else {
        sb.append(this.s);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class echo_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("echo_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);

    public String success;
    public static final int SUCCESS = 0;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(echo_result.class, metaDataMap);
    }

    public echo_result() {
    }

    public echo_result(
      String success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public echo_result(echo_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
    }

    @Override
    public echo_result clone() {
      return new echo_result(this);
    }

    public String getSuccess() {
      return this.success;
    }

    public void setSuccess(String success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof echo_result)
        return this.equals((echo_result)that);
      return false;
    }

    public boolean equals(echo_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRING) {
              this.success = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeString(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("echo_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class dump_config_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("dump_config_args");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(dump_config_args.class, metaDataMap);
    }

    public dump_config_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dump_config_args(dump_config_args other) {
    }

    @Override
    public dump_config_args clone() {
      return new dump_config_args(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dump_config_args)
        return this.equals((dump_config_args)that);
      return false;
    }

    public boolean equals(dump_config_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("dump_config_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class dump_config_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("dump_config_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);

    public String success;
    public static final int SUCCESS = 0;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(dump_config_result.class, metaDataMap);
    }

    public dump_config_result() {
    }

    public dump_config_result(
      String success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dump_config_result(dump_config_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
    }

    @Override
    public dump_config_result clone() {
      return new dump_config_result(this);
    }

    public String getSuccess() {
      return this.success;
    }

    public void setSuccess(String success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dump_config_result)
        return this.equals((dump_config_result)that);
      return false;
    }

    public boolean equals(dump_config_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRING) {
              this.success = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeString(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("dump_config_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_log_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_log_args");
    private static final TField CONTEXT_FIELD_DESC = new TField("context", TType.STRING, (short)1);

    public String context;
    public static final int CONTEXT = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(CONTEXT, new FieldMetaData("context", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_log_args.class, metaDataMap);
    }

    public get_log_args() {
    }

    public get_log_args(
      String context)
    {
      this();
      this.context = context;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_log_args(get_log_args other) {
      if (other.isSetContext()) {
        this.context = other.context;
      }
    }

    @Override
    public get_log_args clone() {
      return new get_log_args(this);
    }

    public String getContext() {
      return this.context;
    }

    public void setContext(String context) {
      this.context = context;
    }

    public void unsetContext() {
      this.context = null;
    }

    // Returns true if field context is set (has been asigned a value) and false otherwise
    public boolean isSetContext() {
      return this.context != null;
    }

    public void setContextIsSet(boolean value) {
      if (!value) {
        this.context = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case CONTEXT:
        if (value == null) {
          unsetContext();
        } else {
          setContext((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case CONTEXT:
        return getContext();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case CONTEXT:
        return isSetContext();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_log_args)
        return this.equals((get_log_args)that);
      return false;
    }

    public boolean equals(get_log_args that) {
      if (that == null)
        return false;

      boolean this_present_context = true && this.isSetContext();
      boolean that_present_context = true && that.isSetContext();
      if (this_present_context || that_present_context) {
        if (!(this_present_context && that_present_context))
          return false;
        if (!this.context.equals(that.context))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_context = true && (isSetContext());
      builder.append(present_context);
      if (present_context)
        builder.append(context);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case CONTEXT:
            if (field.type == TType.STRING) {
              this.context = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.context != null) {
        oprot.writeFieldBegin(CONTEXT_FIELD_DESC);
        oprot.writeString(this.context);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_log_args(");
      boolean first = true;

      sb.append("context:");
      if (this.context == null) {
        sb.append("null");
      } else {
        sb.append(this.context);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_log_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_log_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);
    private static final TField ERROR_FIELD_DESC = new TField("error", TType.STRUCT, (short)1);

    public String success;
    public static final int SUCCESS = 0;
    public QueryNotFoundException error;
    public static final int ERROR = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(ERROR, new FieldMetaData("error", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_log_result.class, metaDataMap);
    }

    public get_log_result() {
    }

    public get_log_result(
      String success,
      QueryNotFoundException error)
    {
      this();
      this.success = success;
      this.error = error;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_log_result(get_log_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
      if (other.isSetError()) {
        this.error = new QueryNotFoundException(other.error);
      }
    }

    @Override
    public get_log_result clone() {
      return new get_log_result(this);
    }

    public String getSuccess() {
      return this.success;
    }

    public void setSuccess(String success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public QueryNotFoundException getError() {
      return this.error;
    }

    public void setError(QueryNotFoundException error) {
      this.error = error;
    }

    public void unsetError() {
      this.error = null;
    }

    // Returns true if field error is set (has been asigned a value) and false otherwise
    public boolean isSetError() {
      return this.error != null;
    }

    public void setErrorIsSet(boolean value) {
      if (!value) {
        this.error = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((String)value);
        }
        break;

      case ERROR:
        if (value == null) {
          unsetError();
        } else {
          setError((QueryNotFoundException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case ERROR:
        return getError();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case ERROR:
        return isSetError();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_log_result)
        return this.equals((get_log_result)that);
      return false;
    }

    public boolean equals(get_log_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_error = true && this.isSetError();
      boolean that_present_error = true && that.isSetError();
      if (this_present_error || that_present_error) {
        if (!(this_present_error && that_present_error))
          return false;
        if (!this.error.equals(that.error))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      boolean present_error = true && (isSetError());
      builder.append(present_error);
      if (present_error)
        builder.append(error);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRING) {
              this.success = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case ERROR:
            if (field.type == TType.STRUCT) {
              this.error = new QueryNotFoundException();
              this.error.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeString(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetError()) {
        oprot.writeFieldBegin(ERROR_FIELD_DESC);
        this.error.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_log_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("error:");
      if (this.error == null) {
        sb.append("null");
      } else {
        sb.append(this.error);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_default_configuration_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_default_configuration_args");
    private static final TField INCLUDE_HADOOP_FIELD_DESC = new TField("include_hadoop", TType.BOOL, (short)1);

    public boolean include_hadoop;
    public static final int INCLUDE_HADOOP = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean include_hadoop = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(INCLUDE_HADOOP, new FieldMetaData("include_hadoop", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_default_configuration_args.class, metaDataMap);
    }

    public get_default_configuration_args() {
    }

    public get_default_configuration_args(
      boolean include_hadoop)
    {
      this();
      this.include_hadoop = include_hadoop;
      this.__isset.include_hadoop = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_default_configuration_args(get_default_configuration_args other) {
      __isset.include_hadoop = other.__isset.include_hadoop;
      this.include_hadoop = other.include_hadoop;
    }

    @Override
    public get_default_configuration_args clone() {
      return new get_default_configuration_args(this);
    }

    public boolean isInclude_hadoop() {
      return this.include_hadoop;
    }

    public void setInclude_hadoop(boolean include_hadoop) {
      this.include_hadoop = include_hadoop;
      this.__isset.include_hadoop = true;
    }

    public void unsetInclude_hadoop() {
      this.__isset.include_hadoop = false;
    }

    // Returns true if field include_hadoop is set (has been asigned a value) and false otherwise
    public boolean isSetInclude_hadoop() {
      return this.__isset.include_hadoop;
    }

    public void setInclude_hadoopIsSet(boolean value) {
      this.__isset.include_hadoop = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case INCLUDE_HADOOP:
        if (value == null) {
          unsetInclude_hadoop();
        } else {
          setInclude_hadoop((Boolean)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case INCLUDE_HADOOP:
        return new Boolean(isInclude_hadoop());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case INCLUDE_HADOOP:
        return isSetInclude_hadoop();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_default_configuration_args)
        return this.equals((get_default_configuration_args)that);
      return false;
    }

    public boolean equals(get_default_configuration_args that) {
      if (that == null)
        return false;

      boolean this_present_include_hadoop = true;
      boolean that_present_include_hadoop = true;
      if (this_present_include_hadoop || that_present_include_hadoop) {
        if (!(this_present_include_hadoop && that_present_include_hadoop))
          return false;
        if (this.include_hadoop != that.include_hadoop)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_include_hadoop = true;
      builder.append(present_include_hadoop);
      if (present_include_hadoop)
        builder.append(include_hadoop);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case INCLUDE_HADOOP:
            if (field.type == TType.BOOL) {
              this.include_hadoop = iprot.readBool();
              this.__isset.include_hadoop = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(INCLUDE_HADOOP_FIELD_DESC);
      oprot.writeBool(this.include_hadoop);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_default_configuration_args(");
      boolean first = true;

      sb.append("include_hadoop:");
      sb.append(this.include_hadoop);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_default_configuration_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_default_configuration_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);

    public List<ConfigVariable> success;
    public static final int SUCCESS = 0;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, ConfigVariable.class))));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_default_configuration_result.class, metaDataMap);
    }

    public get_default_configuration_result() {
    }

    public get_default_configuration_result(
      List<ConfigVariable> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_default_configuration_result(get_default_configuration_result other) {
      if (other.isSetSuccess()) {
        List<ConfigVariable> __this__success = new ArrayList<ConfigVariable>();
        for (ConfigVariable other_element : other.success) {
          __this__success.add(new ConfigVariable(other_element));
        }
        this.success = __this__success;
      }
    }

    @Override
    public get_default_configuration_result clone() {
      return new get_default_configuration_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<ConfigVariable> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(ConfigVariable elem) {
      if (this.success == null) {
        this.success = new ArrayList<ConfigVariable>();
      }
      this.success.add(elem);
    }

    public List<ConfigVariable> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<ConfigVariable> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<ConfigVariable>)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_default_configuration_result)
        return this.equals((get_default_configuration_result)that);
      return false;
    }

    public boolean equals(get_default_configuration_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      HashCodeBuilder builder = new HashCodeBuilder();

      boolean present_success = true && (isSetSuccess());
      builder.append(present_success);
      if (present_success)
        builder.append(success);

      return builder.toHashCode();
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list16 = iprot.readListBegin();
                this.success = new ArrayList<ConfigVariable>(_list16.size);
                for (int _i17 = 0; _i17 < _list16.size; ++_i17)
                {
                  ConfigVariable _elem18;
                  _elem18 = new ConfigVariable();
                  _elem18.read(iprot);
                  this.success.add(_elem18);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (ConfigVariable _iter19 : this.success)          {
            _iter19.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_default_configuration_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

}
