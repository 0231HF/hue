{"body":"<div><p>\n      Returns the execution plan for a statement, showing the low-level mechanisms that Impala will use to read the\n      data, divide the work among nodes in the cluster, and transmit intermediate and final results across the\n      network. Use <span class=\"sql-docs-inline-code\">explain</span> followed by a complete <span class=\"sql-docs-inline-code\">SELECT</span> query. For example:\n    </p><p id=\"../Impala/docs/topics/impala_explain.xml_syntax_blurb\"><b>Syntax:</b></p><div class=\"sql-docs-code-block\">EXPLAIN { <span class=\"sql-docs-variable\">select_query</span> | <span class=\"sql-docs-variable\">ctas_stmt</span> | <span class=\"sql-docs-variable\">insert_stmt</span> }<br/></div><p>\n      The <span class=\"sql-docs-variable\">select_query</span> is a <span class=\"sql-docs-inline-code\">SELECT</span> statement, optionally prefixed by a\n      <span class=\"sql-docs-inline-code\">WITH</span> clause. See <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_select.xml#select\">SELECT Statement</a> for details.\n    </p><p>\n      The <span class=\"sql-docs-variable\">insert_stmt</span> is an <span class=\"sql-docs-inline-code\">INSERT</span> statement that inserts into or overwrites an\n      existing table. It can use either the <span class=\"sql-docs-inline-code\">INSERT ... SELECT</span> or <span class=\"sql-docs-inline-code\">INSERT ...\n      VALUES</span> syntax. See <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_insert.xml#insert\">INSERT Statement</a> for details.\n    </p><p>\n      The <span class=\"sql-docs-variable\">ctas_stmt</span> is a <span class=\"sql-docs-inline-code\">CREATE TABLE</span> statement using the <span class=\"sql-docs-inline-code\">AS\n      SELECT</span> clause, typically abbreviated as a <q>CTAS</q> operation. See\n      <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_create_table.xml#create_table\">CREATE TABLE Statement</a> for details.\n    </p><p id=\"../Impala/docs/topics/impala_explain.xml_usage_notes_blurb\"><b>Usage notes:</b></p><p>\n      You can interpret the output to judge whether the query is performing efficiently, and adjust the query\n      and/or the schema if not. For example, you might change the tests in the <span class=\"sql-docs-inline-code\">WHERE</span> clause, add\n      hints to make join operations more efficient, introduce subqueries, change the order of tables in a join, add\n      or change partitioning for a table, collect column statistics and/or table statistics in Hive, or any other\n      performance tuning steps.\n    </p><p>\n      The <span class=\"sql-docs-inline-code\">EXPLAIN</span> output reminds you if table or column statistics are missing from any table\n      involved in the query. These statistics are important for optimizing queries involving large tables or\n      multi-table joins. See <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_compute_stats.xml#compute_stats\">COMPUTE STATS Statement</a> for how to gather statistics,\n      and <span>perf stats</span> for how to use this information for query tuning.\n    </p><p id=\"../Impala/docs/topics/impala_explain.xml_explain_interpret\">\n        Read the <span class=\"sql-docs-inline-code\">EXPLAIN</span> plan from bottom to top:\n        <ul><li>\n            The last part of the plan shows the low-level details such as the expected amount of data that will be\n            read, where you can judge the effectiveness of your partitioning strategy and estimate how long it will\n            take to scan a table based on total data size and the size of the cluster.\n          </li><li>\n            As you work your way up, next you see the operations that will be parallelized and performed on each\n            Impala node.\n          </li><li>\n            At the higher levels, you see how data flows when intermediate result sets are combined and transmitted\n            from one node to another.\n          </li><li>\n            See <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_explain_level.xml#explain_level\">EXPLAIN_LEVEL Query Option</a> for details about the\n            <span class=\"sql-docs-inline-code\">EXPLAIN_LEVEL</span> query option, which lets you customize how much detail to show in the\n            <span class=\"sql-docs-inline-code\">EXPLAIN</span> plan depending on whether you are doing high-level or low-level tuning,\n            dealing with logical or physical aspects of the query.\n          </li></ul></p><p>\n      If you come from a traditional database background and are not familiar with data warehousing, keep in mind\n      that Impala is optimized for full table scans across very large tables. The structure and distribution of\n      this data is typically not suitable for the kind of indexing and single-row lookups that are common in OLTP\n      environments. Seeing a query scan entirely through a large table is common, not necessarily an indication of\n      an inefficient query. Of course, if you can reduce the volume of scanned data by orders of magnitude, for\n      example by using a query that affects only certain partitions within a partitioned table, then you might be\n      able to optimize a query so that it executes in seconds rather than minutes.\n    </p><p>\n      For more information and examples to help you interpret <span class=\"sql-docs-inline-code\">EXPLAIN</span> output, see\n      <span>perf explain</span>.\n    </p><p><b>Extended EXPLAIN output:</b></p><p>\n      For performance tuning of complex queries, and capacity planning (such as using the admission control and\n      resource management features), you can enable more detailed and informative output for the\n      <span class=\"sql-docs-inline-code\">EXPLAIN</span> statement. In the <span class=\"sql-docs-inline-code\">impala-shell</span> interpreter, issue the command\n      <span class=\"sql-docs-inline-code\">SET EXPLAIN_LEVEL=<span class=\"sql-docs-variable\">level</span></span>, where <span class=\"sql-docs-variable\">level</span> is an integer\n      from 0 to 3 or corresponding mnemonic values <span class=\"sql-docs-inline-code\">minimal</span>, <span class=\"sql-docs-inline-code\">standard</span>,\n      <span class=\"sql-docs-inline-code\">extended</span>, or <span class=\"sql-docs-inline-code\">verbose</span>.\n    </p><p>\n      When extended <span class=\"sql-docs-inline-code\">EXPLAIN</span> output is enabled, <span class=\"sql-docs-inline-code\">EXPLAIN</span> statements print\n      information about estimated memory requirements, minimum number of virtual cores, and so on.\n      </p><p>\n      See <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_explain_level.xml#explain_level\">EXPLAIN_LEVEL Query Option</a> for details and examples.\n    </p><p id=\"../Impala/docs/topics/impala_explain.xml_example_blurb\"><b>Examples:</b></p><p>\n      This example shows how the standard <span class=\"sql-docs-inline-code\">EXPLAIN</span> output moves from the lowest (physical) level to\n      the higher (logical) levels. The query begins by scanning a certain amount of data; each node performs an\n      aggregation operation (evaluating <span class=\"sql-docs-inline-code\">COUNT(*)</span>) on some subset of data that is local to that\n      node; the intermediate results are transmitted back to the coordinator node (labelled here as the\n      <span class=\"sql-docs-inline-code\">EXCHANGE</span> node); lastly, the intermediate results are summed to display the final result.\n    </p><div id=\"../Impala/docs/topics/impala_explain.xml_explain_plan_simple\" class=\"sql-docs-code-block\">[impalad-host:21000] > explain select count(*) from customer_address;<br/>+----------------------------------------------------------+<br/>| Explain String                                           |<br/>+----------------------------------------------------------+<br/>| Estimated Per-Host Requirements: Memory=42.00MB VCores=1 |<br/>|                                                          |<br/>| 03:AGGREGATE [MERGE FINALIZE]                            |<br/>| |  output: sum(count(*))                                 |<br/>| |                                                        |<br/>| 02:EXCHANGE [PARTITION=UNPARTITIONED]                    |<br/>| |                                                        |<br/>| 01:AGGREGATE                                             |<br/>| |  output: count(*)                                      |<br/>| |                                                        |<br/>| 00:SCAN HDFS [default.customer_address]                  |<br/>|    partitions=1/1 size=5.25MB                            |<br/>+----------------------------------------------------------+<br/></div><p>\n      These examples show how the extended <span class=\"sql-docs-inline-code\">EXPLAIN</span> output becomes more accurate and informative as\n      statistics are gathered by the <span class=\"sql-docs-inline-code\">COMPUTE STATS</span> statement. Initially, much of the information\n      about data size and distribution is marked <q>unavailable</q>. Impala can determine the raw data size, but\n      not the number of rows or number of distinct values for each column without additional analysis. The\n      <span class=\"sql-docs-inline-code\">COMPUTE STATS</span> statement performs this analysis, so a subsequent <span class=\"sql-docs-inline-code\">EXPLAIN</span>\n      statement has additional information to use in deciding how to optimize the distributed query.\n    </p><div class=\"sql-docs-code-block\">[localhost:21000] > set explain_level=extended;<br/>EXPLAIN_LEVEL set to extended<br/>[localhost:21000] > explain select x from t1;<br/>[localhost:21000] > explain select x from t1;<br/>+----------------------------------------------------------+<br/>| Explain String                                           |<br/>+----------------------------------------------------------+<br/>| Estimated Per-Host Requirements: Memory=32.00MB VCores=1 |<br/>|                                                          |<br/>| 01:EXCHANGE [PARTITION=UNPARTITIONED]                    |<br/>| |  hosts=1 per-host-mem=unavailable                      |<br/><b>| |  tuple-ids=0 row-size=4B cardinality=unavailable       |</b><br/>| |                                                        |<br/>| 00:SCAN HDFS [default.t2, PARTITION=RANDOM]              |<br/>|    partitions=1/1 size=36B                               |<br/><b>|    table stats: unavailable                              |</b><b>|    column stats: unavailable                             |</b><br/>|    hosts=1 per-host-mem=32.00MB                          |<br/><b>|    tuple-ids=0 row-size=4B cardinality=unavailable       |</b><br/>+----------------------------------------------------------+<br/></div><div class=\"sql-docs-code-block\">[localhost:21000] > compute stats t1;<br/>+-----------------------------------------+<br/>| summary                                 |<br/>+-----------------------------------------+<br/>| Updated 1 partition(s) and 1 column(s). |<br/>+-----------------------------------------+<br/>[localhost:21000] > explain select x from t1;<br/>+----------------------------------------------------------+<br/>| Explain String                                           |<br/>+----------------------------------------------------------+<br/>| Estimated Per-Host Requirements: Memory=64.00MB VCores=1 |<br/>|                                                          |<br/>| 01:EXCHANGE [PARTITION=UNPARTITIONED]                    |<br/>| |  hosts=1 per-host-mem=unavailable                      |<br/>| |  tuple-ids=0 row-size=4B cardinality=0                 |<br/>| |                                                        |<br/>| 00:SCAN HDFS [default.t1, PARTITION=RANDOM]              |<br/>|    partitions=1/1 size=36B                               |<br/><b>|    table stats: 0 rows total                             |</b><b>|    column stats: all                                     |</b><br/>|    hosts=1 per-host-mem=64.00MB                          |<br/><b>|    tuple-ids=0 row-size=4B cardinality=0                 |</b><br/>+----------------------------------------------------------+<br/></div><p id=\"../Impala/docs/topics/impala_explain.xml_security_blurb\"><b>Security considerations:</b></p><p id=\"../Impala/docs/topics/impala_explain.xml_redaction_yes\">\n        If these statements in your environment contain sensitive literal values such as credit card numbers or tax\n        identifiers, Impala can redact this sensitive information when displaying the statements in log files and\n        other administrative contexts. See  for details.\n      </p><p id=\"../Impala/docs/topics/impala_explain.xml_cancel_blurb_no\"><b>Cancellation:</b> Cannot be cancelled.\n      </p><p id=\"../Impala/docs/topics/impala_explain.xml_permissions_blurb\"><b>HDFS permissions:</b></p><p>\n      The user ID that the <span class=\"sql-docs-inline-code\">impalad</span> daemon runs under,\n      typically the <span class=\"sql-docs-inline-code\">impala</span> user, must have read\n      and execute permissions for all applicable directories in all source tables\n      for the query that is being explained.\n      (A <span class=\"sql-docs-inline-code\">SELECT</span> operation could read files from multiple different HDFS directories\n      if the source table is partitioned.)\n    </p><p id=\"../Impala/docs/topics/impala_explain.xml_kudu_blurb\"><b>Kudu considerations:</b></p><p>\n      The <span class=\"sql-docs-inline-code\">EXPLAIN</span> statement displays equivalent plan\n      information for queries against Kudu tables as for queries\n      against HDFS-based tables.\n    </p><p>\n      To see which predicates Impala can <q>push down</q> to Kudu for\n      efficient evaluation, without transmitting unnecessary rows back\n      to Impala, look for the <span class=\"sql-docs-inline-code\">kudu predicates</span> item in\n      the scan phase of the query. The label <span class=\"sql-docs-inline-code\">kudu predicates</span>\n      indicates a condition that can be evaluated efficiently on the Kudu\n      side. The label <span class=\"sql-docs-inline-code\">predicates</span> in a <span class=\"sql-docs-inline-code\">SCAN KUDU</span>\n      node indicates a condition that is evaluated by Impala.\n      For example, in a table with primary key column <span class=\"sql-docs-inline-code\">X</span>\n      and non-primary key column <span class=\"sql-docs-inline-code\">Y</span>, you can see that\n      some operators in the <span class=\"sql-docs-inline-code\">WHERE</span> clause are evaluated\n      immediately by Kudu and others are evaluated later by Impala:\n    </p><div class=\"sql-docs-code-block\"><br/>EXPLAIN SELECT x,y from kudu_table WHERE<br/>  x = 1 AND y NOT IN (2,3) AND z = 1<br/>  AND a IS NOT NULL AND b > 0 AND length(s) > 5;<br/>+----------------<br/>| Explain String<br/>+----------------<br/>...<br/>| 00:SCAN KUDU [kudu_table]<br/>|    predicates: y NOT IN (2, 3), length(s) > 5<br/>|    kudu predicates: a IS NOT NULL, b > 0, x = 1, z = 1<br/></div><p>\n      Only binary predicates, <span class=\"sql-docs-inline-code\">IS NULL</span> and <span class=\"sql-docs-inline-code\">IS NOT NULL</span>\n      (in Impala 2.9 and higher), and <span class=\"sql-docs-inline-code\">IN</span> predicates\n      containing literal values that exactly match the types in the Kudu table, and do not\n      require any casting, can be pushed to Kudu.\n    </p><p id=\"../Impala/docs/topics/impala_explain.xml_related_info\"><b>Related information:</b></p><p><a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_select.xml#select\">SELECT Statement</a>,\n      <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_insert.xml#insert\">INSERT Statement</a>,\n      <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_create_table.xml#create_table\">CREATE TABLE Statement</a>,\n      <span>explain plan</span></p></div>","title":"EXPLAIN Statement"}