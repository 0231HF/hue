{"body":"<div><p>\n      Analytic functions (also known as window functions) are a special category of built-in functions. Like\n      aggregate functions, they examine the contents of multiple input rows to compute each output value. However,\n      rather than being limited to one result value per <span class=\"sql-docs-inline-code\">GROUP BY</span> group, they operate on\n      <span class=\"sql-docs-variable\">windows</span> where the input rows are ordered and grouped using flexible conditions expressed through\n      an <span class=\"sql-docs-inline-code\">OVER()</span> clause.\n    </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_added_in_20\"><b>Added in:</b>Impala 2.0.0</p><p>\n      Some functions, such as <span class=\"sql-docs-inline-code\">LAG()</span> and <span class=\"sql-docs-inline-code\">RANK()</span>, can only be used in this analytic\n      context. Some aggregate functions do double duty: when you call the aggregation functions such as\n      <span class=\"sql-docs-inline-code\">MAX()</span>, <span class=\"sql-docs-inline-code\">SUM()</span>, <span class=\"sql-docs-inline-code\">AVG()</span>, and so on with an\n      <span class=\"sql-docs-inline-code\">OVER()</span> clause, they produce an output value for each row, based on computations across other\n      rows in the window.\n    </p><p>\n      Although analytic functions often compute the same value you would see from an aggregate function in a\n      <span class=\"sql-docs-inline-code\">GROUP BY</span> query, the analytic functions produce a value for each row in the result set rather\n      than a single value for each group. This flexibility lets you include additional columns in the\n      <span class=\"sql-docs-inline-code\">SELECT</span> list, offering more opportunities for organizing and filtering the result set.\n    </p><p>\n      Analytic function calls are only allowed in the <span class=\"sql-docs-inline-code\">SELECT</span> list and in the outermost\n      <span class=\"sql-docs-inline-code\">ORDER BY</span> clause of the query. During query processing, analytic functions are evaluated\n      after other query stages such as joins, <span class=\"sql-docs-inline-code\">WHERE</span>, and <span class=\"sql-docs-inline-code\">GROUP BY</span>,\n    </p><p>\n      The rows that are part of each partition are analyzed by computations across an ordered or unordered set of\n      rows. For example, <span class=\"sql-docs-inline-code\">COUNT()</span> and <span class=\"sql-docs-inline-code\">SUM()</span> might be applied to all the rows in\n      the partition, in which case the order of analysis does not matter. The <span class=\"sql-docs-inline-code\">ORDER BY</span> clause\n      might be used inside the <span class=\"sql-docs-inline-code\">OVER()</span> clause to defines the ordering that applies to functions\n      such as <span class=\"sql-docs-inline-code\">LAG()</span> and <span class=\"sql-docs-inline-code\">FIRST_VALUE()</span>.\n    </p><p>\n      Analytic functions are frequently used in fields such as finance and science to provide trend, outlier, and\n      bucketed analysis for large data sets. You might also see the term <q>window functions</q> in database\n      literature, referring to the sequence of rows (the <q>window</q>) that the function call applies to,\n      particularly when the <span class=\"sql-docs-inline-code\">OVER</span> clause includes a <span class=\"sql-docs-inline-code\">ROWS</span> or <span class=\"sql-docs-inline-code\">RANGE</span>\n      keyword.\n    </p><p>\n      The following sections describe the analytic query clauses and the pure analytic functions provided by\n      Impala. For usage information about aggregate functions in an analytic context, see\n      <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_aggregate_functions.xml#aggregate_functions\">Impala Aggregate Functions</a>.\n    </p></div><div id=\"../Impala/docs/topics/impala_analytic_functions.xml_over\"><h4>OVER Clause</h4><div><p>\n        The <span class=\"sql-docs-inline-code\">OVER</span> clause is required for calls to pure analytic functions such as\n        <span class=\"sql-docs-inline-code\">LEAD()</span>, <span class=\"sql-docs-inline-code\">RANK()</span>, and <span class=\"sql-docs-inline-code\">FIRST_VALUE()</span>. When you include an\n        <span class=\"sql-docs-inline-code\">OVER</span> clause with calls to aggregate functions such as <span class=\"sql-docs-inline-code\">MAX()</span>,\n        <span class=\"sql-docs-inline-code\">COUNT()</span>, or <span class=\"sql-docs-inline-code\">SUM()</span>, they operate as analytic functions.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_syntax_blurb\"><b>Syntax:</b></p><div class=\"sql-docs-code-block\">function(<span class=\"sql-docs-variable\">args</span>) OVER([<span class=\"sql-docs-variable\">partition_by_clause</span>] [<span class=\"sql-docs-variable\">order_by_clause</span> [<span class=\"sql-docs-variable\">window_clause</span>]])<br/><br/>partition_by_clause ::= PARTITION BY <span class=\"sql-docs-variable\">expr</span> [, <span class=\"sql-docs-variable\">expr</span> ...]<br/>order_by_clause ::= ORDER BY <span class=\"sql-docs-variable\">expr</span>  [ASC | DESC] [NULLS FIRST | NULLS LAST] [, <span class=\"sql-docs-variable\">expr</span> [ASC | DESC] [NULLS FIRST | NULLS LAST] ...]<br/>window_clause: See <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_analytic_functions.xml#window_clause\">Window Clause</a></div><p><b>PARTITION BY clause:</b></p><p>\n        The <span class=\"sql-docs-inline-code\">PARTITION BY</span> clause acts much like the <span class=\"sql-docs-inline-code\">GROUP BY</span> clause in the\n        outermost block of a query. It divides the rows into groups containing identical values in one or more\n        columns. These logical groups are known as <span class=\"sql-docs-variable\">partitions</span>. Throughout the discussion of analytic\n        functions, <q>partitions</q> refers to the groups produced by the <span class=\"sql-docs-inline-code\">PARTITION BY</span> clause, not\n        to partitioned tables. However, note the following limitation that applies specifically to analytic function\n        calls involving partitioned tables.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_analytic_partition_pruning_caveat\">\n        In queries involving both analytic functions and partitioned tables, partition pruning only occurs for columns named in the <span class=\"sql-docs-inline-code\">PARTITION BY</span>\n        clause of the analytic function call. For example, if an analytic function query has a clause such as <span class=\"sql-docs-inline-code\">WHERE year=2016</span>,\n        the way to make the query prune all other <span class=\"sql-docs-inline-code\">YEAR</span> partitions is to include <span class=\"sql-docs-inline-code\">PARTITION BY year</span> in the analytic function call;\n        for example, <span class=\"sql-docs-inline-code\">OVER (PARTITION BY year,<span class=\"sql-docs-variable\">other_columns</span><span class=\"sql-docs-variable\">other_analytic_clauses</span>)</span>.\n</p><p>\n        The sequence of results from an analytic function <q>resets</q> for each new partition in the result set.\n        That is, the set of preceding or following rows considered by the analytic function always come from a\n        single partition. Any <span class=\"sql-docs-inline-code\">MAX()</span>, <span class=\"sql-docs-inline-code\">SUM()</span>, <span class=\"sql-docs-inline-code\">ROW_NUMBER()</span>, and so\n        on apply to each partition independently. Omit the <span class=\"sql-docs-inline-code\">PARTITION BY</span> clause to apply the\n        analytic operation to all the rows in the table.\n      </p><p><b>ORDER BY clause:</b></p><p>\n        The <span class=\"sql-docs-inline-code\">ORDER BY</span> clause works much like the <span class=\"sql-docs-inline-code\">ORDER BY</span> clause in the outermost\n        block of a query. It defines the order in which rows are evaluated for the entire input set, or for each\n        group produced by a <span class=\"sql-docs-inline-code\">PARTITION BY</span> clause. You can order by one or multiple expressions, and\n        for each expression optionally choose ascending or descending order and whether nulls come first or last in\n        the sort order. Because this <span class=\"sql-docs-inline-code\">ORDER BY</span> clause only defines the order in which rows are\n        evaluated, if you want the results to be output in a specific order, also include an <span class=\"sql-docs-inline-code\">ORDER\n        BY</span> clause in the outer block of the query.\n      </p><p>\n        When the <span class=\"sql-docs-inline-code\">ORDER BY</span> clause is omitted, the analytic function applies to all items in the\n        group produced by the <span class=\"sql-docs-inline-code\">PARTITION BY</span> clause. When the <span class=\"sql-docs-inline-code\">ORDER BY</span> clause is\n        included, the analysis can apply to all or a subset of the items in the group, depending on the optional\n        window clause.\n      </p><p>\n        The order in which the rows are analyzed is only defined for those columns specified in <span class=\"sql-docs-inline-code\">ORDER\n        BY</span> clauses.\n      </p><p>\n        One difference between the analytic and outer uses of the <span class=\"sql-docs-inline-code\">ORDER BY</span> clause: inside the\n        <span class=\"sql-docs-inline-code\">OVER</span> clause, <span class=\"sql-docs-inline-code\">ORDER BY 1</span> or other integer value is interpreted as a\n        constant sort value (effectively a no-op) rather than referring to column 1.\n      </p><p><b>Window clause:</b></p><p>\n        The window clause is only allowed in combination with an <span class=\"sql-docs-inline-code\">ORDER BY</span> clause. If the\n        <span class=\"sql-docs-inline-code\">ORDER BY</span> clause is specified but the window clause is not, the default window is\n        <span class=\"sql-docs-inline-code\">RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</span>. See\n        <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_analytic_functions.xml#window_clause\"><h4>Window Clause</h4></a> for full details.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_hbase_blurb\"><b>HBase considerations:</b></p><p>\n        Because HBase tables are optimized for single-row lookups rather than full scans, analytic functions using\n        the <span class=\"sql-docs-inline-code\">OVER()</span> clause are not recommended for HBase tables. Although such queries work, their\n        performance is lower than on comparable tables using HDFS data files.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_parquet_blurb\"><b>Parquet considerations:</b></p><p>\n        Analytic functions are very efficient for Parquet tables. The data that is examined during evaluation of\n        the <span class=\"sql-docs-inline-code\">OVER()</span> clause comes from a specified set of columns, and the values for each column\n        are arranged sequentially within each data file.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_text_blurb\"><b>Text table considerations:</b></p><p>\n        Analytic functions are convenient to use with text tables for exploratory business intelligence. When the\n        volume of data is substantial, prefer to use Parquet tables for performance-critical analytic queries.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_added_in_20\"><b>Added in:</b>Impala 2.0.0</p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_example_blurb\"><b>Examples:</b></p><p>\n        The following example shows how to synthesize a numeric sequence corresponding to all the rows in a table.\n        The new table has the same columns as the old one, plus an additional column <span class=\"sql-docs-inline-code\">ID</span> containing\n        the integers 1, 2, 3, and so on, corresponding to the order of a <span class=\"sql-docs-inline-code\">TIMESTAMP</span> column in the\n        original table.\n      </p><div class=\"sql-docs-code-block\">CREATE TABLE events_with_id AS<br/>  SELECT<br/>    row_number() OVER (ORDER BY date_and_time) AS id,<br/>    c1, c2, c3, c4<br/>  FROM events;<br/></div><p>\n        The following example shows how to determine the number of rows containing each value for a column. Unlike\n        a corresponding <span class=\"sql-docs-inline-code\">GROUP BY</span> query, this one can analyze a single column and still return all\n        values (not just the distinct ones) from the other columns.\n      </p><div class=\"sql-docs-code-block\">SELECT x, y, z,<br/>  count() OVER (PARTITION BY x) AS how_many_x<br/>FROM t1;<br/></div><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_restrictions_blurb\"><b>Restrictions:</b></p><p>\n        You cannot directly combine the <span class=\"sql-docs-inline-code\">DISTINCT</span> operator with analytic function calls. You can\n        put the analytic function call in a <span class=\"sql-docs-inline-code\">WITH</span> clause or an inline view, and apply the\n        <span class=\"sql-docs-inline-code\">DISTINCT</span> operator to its result set.\n      </p><div class=\"sql-docs-code-block\">WITH t1 AS (SELECT x, sum(x) OVER (PARTITION BY x) AS total FROM t1)<br/>  SELECT DISTINCT x, total FROM t1;<br/></div></div></div><div id=\"../Impala/docs/topics/impala_analytic_functions.xml_window_clause\"><h4>Window Clause</h4><div><p>\n        Certain analytic functions accept an optional <span class=\"sql-docs-variable\">window clause</span>, which makes the function analyze\n        only certain rows <q>around</q> the current row rather than all rows in the partition. For example, you can\n        get a moving average by specifying some number of preceding and following rows, or a running count or\n        running total by specifying all rows up to the current position. This clause can result in different\n        analytic results for rows within the same partition.\n      </p><p>\n        The window clause is supported with the <span class=\"sql-docs-inline-code\">AVG()</span>, <span class=\"sql-docs-inline-code\">COUNT()</span>,\n        <span class=\"sql-docs-inline-code\">FIRST_VALUE()</span>, <span class=\"sql-docs-inline-code\">LAST_VALUE()</span>, and <span class=\"sql-docs-inline-code\">SUM()</span> functions.\n\n        For <span class=\"sql-docs-inline-code\">MAX()</span> and <span class=\"sql-docs-inline-code\">MIN()</span>, the window clause only allowed if the start bound is\n        <span class=\"sql-docs-inline-code\">UNBOUNDED PRECEDING</span></p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_syntax_blurb\"><b>Syntax:</b></p><div class=\"sql-docs-code-block\">ROWS BETWEEN [ { <span class=\"sql-docs-variable\">m</span> | UNBOUNDED } PRECEDING | CURRENT ROW] [ AND [CURRENT ROW | { UNBOUNDED | <span class=\"sql-docs-variable\">n</span> } FOLLOWING] ]<br/>RANGE BETWEEN [ {<span class=\"sql-docs-variable\">m</span> | UNBOUNDED } PRECEDING | CURRENT ROW] [ AND [CURRENT ROW | { UNBOUNDED | <span class=\"sql-docs-variable\">n</span> } FOLLOWING] ]</div><p><span class=\"sql-docs-inline-code\">ROWS BETWEEN</span> defines the size of the window in terms of the indexes of the rows in the\n        result set. The size of the window is predictable based on the clauses the position within the result set.\n      </p><p><span class=\"sql-docs-inline-code\">RANGE BETWEEN</span> does not currently support numeric arguments to define a variable-size\n        sliding window.\n</p><p>\n        Currently, Impala supports only some combinations of arguments to the <span class=\"sql-docs-inline-code\">RANGE</span> clause:\n      </p><ul><li><span class=\"sql-docs-inline-code\">RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</span> (the default when <span class=\"sql-docs-inline-code\">ORDER\n          BY</span> is specified and the window clause is omitted)\n        </li><li><span class=\"sql-docs-inline-code\">RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING</span></li><li><span class=\"sql-docs-inline-code\">RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</span></li></ul><p>\n        When <span class=\"sql-docs-inline-code\">RANGE</span> is used, <span class=\"sql-docs-inline-code\">CURRENT ROW</span> includes not just the current row but all\n        rows that are tied with the current row based on the <span class=\"sql-docs-inline-code\">ORDER BY</span> expressions.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_added_in_20\"><b>Added in:</b>Impala 2.0.0</p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_example_blurb\"><b>Examples:</b></p><p>\n        The following examples show financial data for a fictional stock symbol <span class=\"sql-docs-inline-code\">JDR</span>. The closing\n        price moves up and down each day.\n      </p><div class=\"sql-docs-code-block\">create table stock_ticker (stock_symbol string, closing_price decimal(8,2), closing_date timestamp);<br/>...load some data...<br/>select * from stock_ticker order by stock_symbol, closing_date<br/>+--------------+---------------+---------------------+<br/>| stock_symbol | closing_price | closing_date        |<br/>+--------------+---------------+---------------------+<br/>| JDR          | 12.86         | 2014-10-02 00:00:00 |<br/>| JDR          | 12.89         | 2014-10-03 00:00:00 |<br/>| JDR          | 12.94         | 2014-10-04 00:00:00 |<br/>| JDR          | 12.55         | 2014-10-05 00:00:00 |<br/>| JDR          | 14.03         | 2014-10-06 00:00:00 |<br/>| JDR          | 14.75         | 2014-10-07 00:00:00 |<br/>| JDR          | 13.98         | 2014-10-08 00:00:00 |<br/>+--------------+---------------+---------------------+<br/></div><p>\n        The queries use analytic functions with window clauses to compute moving averages of the closing price. For\n        example, <span class=\"sql-docs-inline-code\">ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING</span> produces an average of the value from a\n        3-day span, producing a different value for each row. The first row, which has no preceding row, only gets\n        averaged with the row following it. If the table contained more than one stock symbol, the\n        <span class=\"sql-docs-inline-code\">PARTITION BY</span> clause would limit the window for the moving average to only consider the\n        prices for a single stock.\n      </p><div class=\"sql-docs-code-block\">select stock_symbol, closing_date, closing_price,<br/>  avg(closing_price) over (partition by stock_symbol order by closing_date<br/>    rows between 1 preceding and 1 following) as moving_average<br/>  from stock_ticker;<br/>+--------------+---------------------+---------------+----------------+<br/>| stock_symbol | closing_date        | closing_price | moving_average |<br/>+--------------+---------------------+---------------+----------------+<br/>| JDR          | 2014-10-02 00:00:00 | 12.86         | 12.87          |<br/>| JDR          | 2014-10-03 00:00:00 | 12.89         | 12.89          |<br/>| JDR          | 2014-10-04 00:00:00 | 12.94         | 12.79          |<br/>| JDR          | 2014-10-05 00:00:00 | 12.55         | 13.17          |<br/>| JDR          | 2014-10-06 00:00:00 | 14.03         | 13.77          |<br/>| JDR          | 2014-10-07 00:00:00 | 14.75         | 14.25          |<br/>| JDR          | 2014-10-08 00:00:00 | 13.98         | 14.36          |<br/>+--------------+---------------------+---------------+----------------+<br/></div><p>\n        The clause <span class=\"sql-docs-inline-code\">ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</span> produces a cumulative moving\n        average, from the earliest data up to the value for each day.\n      </p><div class=\"sql-docs-code-block\">select stock_symbol, closing_date, closing_price,<br/>  avg(closing_price) over (partition by stock_symbol order by closing_date<br/>    rows between unbounded preceding and current row) as moving_average<br/>  from stock_ticker;<br/>+--------------+---------------------+---------------+----------------+<br/>| stock_symbol | closing_date        | closing_price | moving_average |<br/>+--------------+---------------------+---------------+----------------+<br/>| JDR          | 2014-10-02 00:00:00 | 12.86         | 12.86          |<br/>| JDR          | 2014-10-03 00:00:00 | 12.89         | 12.87          |<br/>| JDR          | 2014-10-04 00:00:00 | 12.94         | 12.89          |<br/>| JDR          | 2014-10-05 00:00:00 | 12.55         | 12.81          |<br/>| JDR          | 2014-10-06 00:00:00 | 14.03         | 13.05          |<br/>| JDR          | 2014-10-07 00:00:00 | 14.75         | 13.33          |<br/>| JDR          | 2014-10-08 00:00:00 | 13.98         | 13.42          |<br/>+--------------+---------------------+---------------+----------------+<br/></div></div></div><div id=\"../Impala/docs/topics/impala_analytic_functions.xml_avg_analytic\"><h4>AVG Function - Analytic Context</h4><div><p>\n        You can include an <span class=\"sql-docs-inline-code\">OVER</span> clause with a call to this function to use it as an analytic\n        function. See <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_avg.xml#avg\">AVG Function</a> for details and examples.\n      </p></div></div><div id=\"../Impala/docs/topics/impala_analytic_functions.xml_count_analytic\"><h4>COUNT Function - Analytic Context</h4><div><p>\n        You can include an <span class=\"sql-docs-inline-code\">OVER</span> clause with a call to this function to use it as an analytic\n        function. See <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_count.xml#count\">COUNT Function</a> for details and examples.\n      </p></div></div><div id=\"../Impala/docs/topics/impala_analytic_functions.xml_cume_dist\"><h4>CUME_DIST Function (Impala 2.3 or higher only)</h4><div><p>\n        Returns the cumulative distribution of a value. The value for each row in the result set is greater than 0\n        and less than or equal to 1.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_syntax_blurb\"><b>Syntax:</b></p><div class=\"sql-docs-code-block\">CUME_DIST (<span class=\"sql-docs-variable\">expr</span>)<br/>  OVER ([<span class=\"sql-docs-variable\">partition_by_clause</span>] <span class=\"sql-docs-variable\">order_by_clause</span>)<br/></div><p>\n        The <span class=\"sql-docs-inline-code\">ORDER BY</span> clause is required. The <span class=\"sql-docs-inline-code\">PARTITION BY</span> clause is optional. The\n        window clause is not allowed.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_usage_notes_blurb\"><b>Usage notes:</b></p><p>\n        Within each partition of the result set, the <span class=\"sql-docs-inline-code\">CUME_DIST()</span> value represents an ascending\n        sequence that ends at 1. Each value represents the proportion of rows in the partition whose values are\n        less than or equal to the value in the current row.\n      </p><p>\n        If the sequence of input values contains ties, the <span class=\"sql-docs-inline-code\">CUME_DIST()</span> results are identical for the\n        tied values.\n      </p><p>\n        Impala only supports the <span class=\"sql-docs-inline-code\">CUME_DIST()</span> function in an analytic context, not as a regular\n        aggregate function.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_example_blurb\"><b>Examples:</b></p><p>\n        This example uses a table with 9 rows. The <span class=\"sql-docs-inline-code\">CUME_DIST()</span>\n        function evaluates the entire table because there is no <span class=\"sql-docs-inline-code\">PARTITION BY</span> clause,\n        with the rows ordered by the weight of the animal.\n        the sequence of values shows that 1/9 of the values are less than or equal to the lightest\n        animal (mouse), 2/9 of the values are less than or equal to the second-lightest animal,\n        and so on up to the heaviest animal (elephant), where 9/9 of the rows are less than or\n        equal to its weight.\n      </p><div class=\"sql-docs-code-block\">create table animals (name string, kind string, kilos decimal(9,3));<br/>insert into animals values<br/>  ('Elephant', 'Mammal', 4000), ('Giraffe', 'Mammal', 1200), ('Mouse', 'Mammal', 0.020),<br/>  ('Condor', 'Bird', 15), ('Horse', 'Mammal', 500), ('Owl', 'Bird', 2.5),<br/>  ('Ostrich', 'Bird', 145), ('Polar bear', 'Mammal', 700), ('Housecat', 'Mammal', 5);<br/><br/>select name, cume_dist() over (order by kilos) from animals;<br/>+------------+-----------------------+<br/>| name       | cume_dist() OVER(...) |<br/>+------------+-----------------------+<br/>| Elephant   | 1                     |<br/>| Giraffe    | 0.8888888888888888    |<br/>| Polar bear | 0.7777777777777778    |<br/>| Horse      | 0.6666666666666666    |<br/>| Ostrich    | 0.5555555555555556    |<br/>| Condor     | 0.4444444444444444    |<br/>| Housecat   | 0.3333333333333333    |<br/>| Owl        | 0.2222222222222222    |<br/>| Mouse      | 0.1111111111111111    |<br/>+------------+-----------------------+<br/></div><p>\n        Using a <span class=\"sql-docs-inline-code\">PARTITION BY</span> clause produces a separate sequence for each partition\n        group, in this case one for mammals and one for birds. Because there are 3 birds and 6 mammals,\n        the sequence illustrates how 1/3 of the <q>Bird</q> rows have a <span class=\"sql-docs-inline-code\">kilos</span> value that is less than or equal to\n        the lightest bird, 1/6 of the <q>Mammal</q> rows have a <span class=\"sql-docs-inline-code\">kilos</span> value that is less than or equal to\n        the lightest mammal, and so on until both the heaviest bird and heaviest mammal have a <span class=\"sql-docs-inline-code\">CUME_DIST()</span>\n        value of 1.\n      </p><div class=\"sql-docs-code-block\">select name, kind, cume_dist() over (partition by kind order by kilos) from animals<br/>+------------+--------+-----------------------+<br/>| name       | kind   | cume_dist() OVER(...) |<br/>+------------+--------+-----------------------+<br/>| Ostrich    | Bird   | 1                     |<br/>| Condor     | Bird   | 0.6666666666666666    |<br/>| Owl        | Bird   | 0.3333333333333333    |<br/>| Elephant   | Mammal | 1                     |<br/>| Giraffe    | Mammal | 0.8333333333333334    |<br/>| Polar bear | Mammal | 0.6666666666666666    |<br/>| Horse      | Mammal | 0.5                   |<br/>| Housecat   | Mammal | 0.3333333333333333    |<br/>| Mouse      | Mammal | 0.1666666666666667    |<br/>+------------+--------+-----------------------+<br/></div><p>\n        We can reverse the ordering within each partition group by using an <span class=\"sql-docs-inline-code\">ORDER BY ... DESC</span>\n        clause within the <span class=\"sql-docs-inline-code\">OVER()</span> clause. Now the lightest (smallest value of <span class=\"sql-docs-inline-code\">kilos</span>)\n        animal of each kind has a <span class=\"sql-docs-inline-code\">CUME_DIST()</span> value of 1.\n      </p><div class=\"sql-docs-code-block\">select name, kind, cume_dist() over (partition by kind order by kilos desc) from animals<br/>+------------+--------+-----------------------+<br/>| name       | kind   | cume_dist() OVER(...) |<br/>+------------+--------+-----------------------+<br/>| Owl        | Bird   | 1                     |<br/>| Condor     | Bird   | 0.6666666666666666    |<br/>| Ostrich    | Bird   | 0.3333333333333333    |<br/>| Mouse      | Mammal | 1                     |<br/>| Housecat   | Mammal | 0.8333333333333334    |<br/>| Horse      | Mammal | 0.6666666666666666    |<br/>| Polar bear | Mammal | 0.5                   |<br/>| Giraffe    | Mammal | 0.3333333333333333    |<br/>| Elephant   | Mammal | 0.1666666666666667    |<br/>+------------+--------+-----------------------+<br/></div><p>\n        The following example manufactures some rows with identical values in the <span class=\"sql-docs-inline-code\">kilos</span> column,\n        to demonstrate how the results look in case of tie values. For simplicity, it only shows the <span class=\"sql-docs-inline-code\">CUME_DIST()</span>\n        sequence for the <q>Bird</q> rows. Now with 3 rows all with a value of 15, all of those rows have the same\n        <span class=\"sql-docs-inline-code\">CUME_DIST()</span> value. 4/5 of the rows have a value for <span class=\"sql-docs-inline-code\">kilos</span> that is less than or\n        equal to 15.\n      </p><div class=\"sql-docs-code-block\">insert into animals values ('California Condor', 'Bird', 15), ('Andean Condor', 'Bird', 15)<br/><br/>select name, kind, cume_dist() over (order by kilos) from animals where kind = 'Bird';<br/>+-------------------+------+-----------------------+<br/>| name              | kind | cume_dist() OVER(...) |<br/>+-------------------+------+-----------------------+<br/>| Ostrich           | Bird | 1                     |<br/>| Condor            | Bird | 0.8                   |<br/>| California Condor | Bird | 0.8                   |<br/>| Andean Condor     | Bird | 0.8                   |<br/>| Owl               | Bird | 0.2                   |<br/>+-------------------+------+-----------------------+<br/></div><p>\n        The following example shows how to use an <span class=\"sql-docs-inline-code\">ORDER BY</span> clause in the outer block\n        to order the result set in case of ties. Here, all the <q>Bird</q> rows are together, then in descending order\n        by the result of the <span class=\"sql-docs-inline-code\">CUME_DIST()</span> function, and all tied <span class=\"sql-docs-inline-code\">CUME_DIST()</span>\n        values are ordered by the animal name.\n      </p><div class=\"sql-docs-code-block\">select name, kind, cume_dist() over (partition by kind order by kilos) as ordering<br/>  from animals<br/>where<br/>  kind = 'Bird'<br/>order by kind, ordering desc, name;<br/>+-------------------+------+----------+<br/>| name              | kind | ordering |<br/>+-------------------+------+----------+<br/>| Ostrich           | Bird | 1        |<br/>| Andean Condor     | Bird | 0.8      |<br/>| California Condor | Bird | 0.8      |<br/>| Condor            | Bird | 0.8      |<br/>| Owl               | Bird | 0.2      |<br/>+-------------------+------+----------+<br/></div></div></div><div id=\"../Impala/docs/topics/impala_analytic_functions.xml_dense_rank\"><h4>DENSE_RANK Function</h4><div><p>\n        Returns an ascending sequence of integers, starting with 1. The output sequence produces duplicate integers\n        for duplicate values of the <span class=\"sql-docs-inline-code\">ORDER BY</span> expressions. After generating duplicate output values\n        for the <q>tied</q> input values, the function continues the sequence with the next higher integer.\n        Therefore, the sequence contains duplicates but no gaps when the input contains duplicates. Starts the\n        sequence over for each group produced by the <span class=\"sql-docs-inline-code\">PARTITIONED BY</span> clause.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_syntax_blurb\"><b>Syntax:</b></p><div class=\"sql-docs-code-block\">DENSE_RANK() OVER([<span class=\"sql-docs-variable\">partition_by_clause</span>] <span class=\"sql-docs-variable\">order_by_clause</span>)</div><p>\n        The <span class=\"sql-docs-inline-code\">PARTITION BY</span> clause is optional. The <span class=\"sql-docs-inline-code\">ORDER BY</span> clause is required. The\n        window clause is not allowed.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_usage_notes_blurb\"><b>Usage notes:</b></p><p>\n        Often used for top-N and bottom-N queries. For example, it could produce a <q>top 10</q> report including\n        all the items with the 10 highest values, even if several items tied for 1st place.\n      </p><p>\n        Similar to <span class=\"sql-docs-inline-code\">ROW_NUMBER</span> and <span class=\"sql-docs-inline-code\">RANK</span>. These functions differ in how they treat\n        duplicate combinations of values.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_added_in_20\"><b>Added in:</b>Impala 2.0.0</p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_example_blurb\"><b>Examples:</b></p><p>\n        The following example demonstrates how the <span class=\"sql-docs-inline-code\">DENSE_RANK()</span> function identifies where each\n        value <q>places</q> in the result set, producing the same result for duplicate values, but with a strict\n        sequence from 1 to the number of groups. For example, when results are ordered by the <span class=\"sql-docs-inline-code\">X</span>\n        column, both <span class=\"sql-docs-inline-code\">1</span> values are tied for first; both <span class=\"sql-docs-inline-code\">2</span> values are tied for\n        second; and so on.\n      </p><div class=\"sql-docs-code-block\">select x, dense_rank() over(order by x) as rank, property from int_t;<br/>+----+------+----------+<br/>| x  | rank | property |<br/>+----+------+----------+<br/>| 1  | 1    | square   |<br/>| 1  | 1    | odd      |<br/>| 2  | 2    | even     |<br/>| 2  | 2    | prime    |<br/>| 3  | 3    | prime    |<br/>| 3  | 3    | odd      |<br/>| 4  | 4    | even     |<br/>| 4  | 4    | square   |<br/>| 5  | 5    | odd      |<br/>| 5  | 5    | prime    |<br/>| 6  | 6    | even     |<br/>| 6  | 6    | perfect  |<br/>| 7  | 7    | lucky    |<br/>| 7  | 7    | lucky    |<br/>| 7  | 7    | lucky    |<br/>| 7  | 7    | odd      |<br/>| 7  | 7    | prime    |<br/>| 8  | 8    | even     |<br/>| 9  | 9    | square   |<br/>| 9  | 9    | odd      |<br/>| 10 | 10   | round    |<br/>| 10 | 10   | even     |<br/>+----+------+----------+<br/></div><p>\n        The following examples show how the <span class=\"sql-docs-inline-code\">DENSE_RANK()</span> function is affected by the\n        <span class=\"sql-docs-inline-code\">PARTITION</span> property within the <span class=\"sql-docs-inline-code\">ORDER BY</span> clause.\n      </p><p>\n        Partitioning by the <span class=\"sql-docs-inline-code\">PROPERTY</span> column groups all the even, odd, and so on values together,\n        and <span class=\"sql-docs-inline-code\">DENSE_RANK()</span> returns the place of each value within the group, producing several\n        ascending sequences.\n      </p><div class=\"sql-docs-code-block\">select x, dense_rank() over(partition by property order by x) as rank, property from int_t;<br/>+----+------+----------+<br/>| x  | rank | property |<br/>+----+------+----------+<br/>| 2  | 1    | even     |<br/>| 4  | 2    | even     |<br/>| 6  | 3    | even     |<br/>| 8  | 4    | even     |<br/>| 10 | 5    | even     |<br/>| 7  | 1    | lucky    |<br/>| 7  | 1    | lucky    |<br/>| 7  | 1    | lucky    |<br/>| 1  | 1    | odd      |<br/>| 3  | 2    | odd      |<br/>| 5  | 3    | odd      |<br/>| 7  | 4    | odd      |<br/>| 9  | 5    | odd      |<br/>| 6  | 1    | perfect  |<br/>| 2  | 1    | prime    |<br/>| 3  | 2    | prime    |<br/>| 5  | 3    | prime    |<br/>| 7  | 4    | prime    |<br/>| 10 | 1    | round    |<br/>| 1  | 1    | square   |<br/>| 4  | 2    | square   |<br/>| 9  | 3    | square   |<br/>+----+------+----------+<br/></div><p>\n        Partitioning by the <span class=\"sql-docs-inline-code\">X</span> column groups all the duplicate numbers together and returns the\n        place each value within the group; because each value occurs only 1 or 2 times,\n        <span class=\"sql-docs-inline-code\">DENSE_RANK()</span> designates each <span class=\"sql-docs-inline-code\">X</span> value as either first or second within its\n        group.\n      </p><div class=\"sql-docs-code-block\">select x, dense_rank() over(partition by x order by property) as rank, property from int_t;<br/>+----+------+----------+<br/>| x  | rank | property |<br/>+----+------+----------+<br/>| 1  | 1    | odd      |<br/>| 1  | 2    | square   |<br/>| 2  | 1    | even     |<br/>| 2  | 2    | prime    |<br/>| 3  | 1    | odd      |<br/>| 3  | 2    | prime    |<br/>| 4  | 1    | even     |<br/>| 4  | 2    | square   |<br/>| 5  | 1    | odd      |<br/>| 5  | 2    | prime    |<br/>| 6  | 1    | even     |<br/>| 6  | 2    | perfect  |<br/>| 7  | 1    | lucky    |<br/>| 7  | 1    | lucky    |<br/>| 7  | 1    | lucky    |<br/>| 7  | 2    | odd      |<br/>| 7  | 3    | prime    |<br/>| 8  | 1    | even     |<br/>| 9  | 1    | odd      |<br/>| 9  | 2    | square   |<br/>| 10 | 1    | even     |<br/>| 10 | 2    | round    |<br/>+----+------+----------+<br/></div><p>\n        The following example shows how <span class=\"sql-docs-inline-code\">DENSE_RANK()</span> produces a continuous sequence while still\n        allowing for ties. In this case, Croesus and Midas both have the second largest fortune, while Crassus has\n        the third largest. (In <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_analytic_functions.xml#rank\"><h4>RANK Function</h4></a>, you see a similar query with the\n        <span class=\"sql-docs-inline-code\">RANK()</span> function that shows that while Crassus has the third largest fortune, he is the\n        fourth richest person.)\n      </p><div class=\"sql-docs-code-block\">select dense_rank() over (order by net_worth desc) as placement, name, net_worth from wealth order by placement, name;<br/>+-----------+---------+---------------+<br/>| placement | name    | net_worth     |<br/>+-----------+---------+---------------+<br/>| 1         | Solomon | 2000000000.00 |<br/>| 2         | Croesus | 1000000000.00 |<br/>| 2         | Midas   | 1000000000.00 |<br/>| 3         | Crassus | 500000000.00  |<br/>| 4         | Scrooge | 80000000.00   |<br/>+-----------+---------+---------------+<br/></div><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_related_info\"><b>Related information:</b></p><p><a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_analytic_functions.xml#rank\"><h4>RANK Function</h4></a>, <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_analytic_functions.xml#row_number\"><h4>ROW_NUMBER Function</h4></a></p></div></div><div id=\"../Impala/docs/topics/impala_analytic_functions.xml_first_value\"><h4>FIRST_VALUE Function</h4><div><p>\n        Returns the expression value from the first row in the window. The return value is <span class=\"sql-docs-inline-code\">NULL</span> if\n        the input expression is <span class=\"sql-docs-inline-code\">NULL</span>.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_syntax_blurb\"><b>Syntax:</b></p><div class=\"sql-docs-code-block\">FIRST_VALUE(<span class=\"sql-docs-variable\">expr</span>) OVER([<span class=\"sql-docs-variable\">partition_by_clause</span>] <span class=\"sql-docs-variable\">order_by_clause</span> [<span class=\"sql-docs-variable\">window_clause</span>])</div><p>\n        The <span class=\"sql-docs-inline-code\">PARTITION BY</span> clause is optional. The <span class=\"sql-docs-inline-code\">ORDER BY</span> clause is required. The\n        window clause is optional.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_usage_notes_blurb\"><b>Usage notes:</b></p><p>\n        If any duplicate values occur in the tuples evaluated by the <span class=\"sql-docs-inline-code\">ORDER BY</span> clause, the result\n        of this function is not deterministic. Consider adding additional <span class=\"sql-docs-inline-code\">ORDER BY</span> columns to\n        ensure consistent ordering.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_added_in_20\"><b>Added in:</b>Impala 2.0.0</p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_example_blurb\"><b>Examples:</b></p><p>\n        The following example shows a table with a wide variety of country-appropriate greetings. For consistency,\n        we want to standardize on a single greeting for each country. The <span class=\"sql-docs-inline-code\">FIRST_VALUE()</span> function\n        helps to produce a mail merge report where every person from the same country is addressed with the same\n        greeting.\n      </p><div class=\"sql-docs-code-block\">select name, country, greeting from mail_merge<br/>+---------+---------+--------------+<br/>| name    | country | greeting     |<br/>+---------+---------+--------------+<br/>| Pete    | USA     | Hello        |<br/>| John    | USA     | Hi           |<br/>| Boris   | Germany | Guten tag    |<br/>| Michael | Germany | Guten morgen |<br/>| Bjorn   | Sweden  | Hej          |<br/>| Mats    | Sweden  | Tja          |<br/>+---------+---------+--------------+<br/><br/>select country, name,<br/>  first_value(greeting)<br/>    over (partition by country order by name, greeting) as greeting<br/>  from mail_merge;<br/>+---------+---------+-----------+<br/>| country | name    | greeting  |<br/>+---------+---------+-----------+<br/>| Germany | Boris   | Guten tag |<br/>| Germany | Michael | Guten tag |<br/>| Sweden  | Bjorn   | Hej       |<br/>| Sweden  | Mats    | Hej       |<br/>| USA     | John    | Hi        |<br/>| USA     | Pete    | Hi        |<br/>+---------+---------+-----------+<br/></div><p>\n        Changing the order in which the names are evaluated changes which greeting is applied to each group.\n      </p><div class=\"sql-docs-code-block\">select country, name,<br/>  first_value(greeting)<br/>    over (partition by country order by name desc, greeting) as greeting<br/>  from mail_merge;<br/>+---------+---------+--------------+<br/>| country | name    | greeting     |<br/>+---------+---------+--------------+<br/>| Germany | Michael | Guten morgen |<br/>| Germany | Boris   | Guten morgen |<br/>| Sweden  | Mats    | Tja          |<br/>| Sweden  | Bjorn   | Tja          |<br/>| USA     | Pete    | Hello        |<br/>| USA     | John    | Hello        |<br/>+---------+---------+--------------+<br/></div><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_related_info\"><b>Related information:</b></p><p><a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_analytic_functions.xml#last_value\"><h4>LAST_VALUE Function</h4></a></p></div></div><div id=\"../Impala/docs/topics/impala_analytic_functions.xml_lag\"><h4>LAG Function</h4><div><p>\n        This function returns the value of an expression using column values from a preceding row. You specify an\n        integer offset, which designates a row position some number of rows previous to the current row. Any column\n        references in the expression argument refer to column values from that prior row. Typically, the table\n        contains a time sequence or numeric sequence column that clearly distinguishes the ordering of the rows.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_syntax_blurb\"><b>Syntax:</b></p><div class=\"sql-docs-code-block\">LAG (<span class=\"sql-docs-variable\">expr</span> [, <span class=\"sql-docs-variable\">offset</span>] [, <span class=\"sql-docs-variable\">default</span>])<br/>  OVER ([<span class=\"sql-docs-variable\">partition_by_clause</span>] <span class=\"sql-docs-variable\">order_by_clause</span>)</div><p>\n        The <span class=\"sql-docs-inline-code\">ORDER BY</span> clause is required. The <span class=\"sql-docs-inline-code\">PARTITION BY</span> clause is optional. The\n        window clause is not allowed.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_usage_notes_blurb\"><b>Usage notes:</b></p><p>\n        Sometimes used an an alternative to doing a self-join.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_added_in_20\"><b>Added in:</b>Impala 2.0.0</p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_example_blurb\"><b>Examples:</b></p><p>\n        The following example uses the same stock data created in <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_analytic_functions.xml#window_clause\"><h4>Window Clause</h4></a>. For each day, the\n        query prints the closing price alongside the previous day's closing price. The first row for each stock\n        symbol has no previous row, so that <span class=\"sql-docs-inline-code\">LAG()</span> value is <span class=\"sql-docs-inline-code\">NULL</span>.\n      </p><div class=\"sql-docs-code-block\">select stock_symbol, closing_date, closing_price,<br/>    lag(closing_price,1) over (partition by stock_symbol order by closing_date) as \"yesterday closing\"<br/>  from stock_ticker<br/>    order by closing_date;<br/>+--------------+---------------------+---------------+-------------------+<br/>| stock_symbol | closing_date        | closing_price | yesterday closing |<br/>+--------------+---------------------+---------------+-------------------+<br/>| JDR          | 2014-09-13 00:00:00 | 12.86         | NULL              |<br/>| JDR          | 2014-09-14 00:00:00 | 12.89         | 12.86             |<br/>| JDR          | 2014-09-15 00:00:00 | 12.94         | 12.89             |<br/>| JDR          | 2014-09-16 00:00:00 | 12.55         | 12.94             |<br/>| JDR          | 2014-09-17 00:00:00 | 14.03         | 12.55             |<br/>| JDR          | 2014-09-18 00:00:00 | 14.75         | 14.03             |<br/>| JDR          | 2014-09-19 00:00:00 | 13.98         | 14.75             |<br/>+--------------+---------------------+---------------+-------------------+<br/></div><p>\n        The following example does an arithmetic operation between the current row and a value from the previous\n        row, to produce a delta value for each day. This example also demonstrates how <span class=\"sql-docs-inline-code\">ORDER BY</span>\n        works independently in the different parts of the query. The <span class=\"sql-docs-inline-code\">ORDER BY closing_date</span> in the\n        <span class=\"sql-docs-inline-code\">OVER</span> clause makes the query analyze the rows in chronological order. Then the outer query\n        block uses <span class=\"sql-docs-inline-code\">ORDER BY closing_date DESC</span> to present the results with the most recent date\n        first.\n      </p><div class=\"sql-docs-code-block\">select stock_symbol, closing_date, closing_price,<br/>    cast(<br/>      closing_price - lag(closing_price,1) over<br/>        (partition by stock_symbol order by closing_date)<br/>      as decimal(8,2)<br/>    )<br/>    as \"change from yesterday\"<br/>  from stock_ticker<br/>    order by closing_date desc;<br/>+--------------+---------------------+---------------+-----------------------+<br/>| stock_symbol | closing_date        | closing_price | change from yesterday |<br/>+--------------+---------------------+---------------+-----------------------+<br/>| JDR          | 2014-09-19 00:00:00 | 13.98         | -0.76                 |<br/>| JDR          | 2014-09-18 00:00:00 | 14.75         | 0.72                  |<br/>| JDR          | 2014-09-17 00:00:00 | 14.03         | 1.47                  |<br/>| JDR          | 2014-09-16 00:00:00 | 12.55         | -0.38                 |<br/>| JDR          | 2014-09-15 00:00:00 | 12.94         | 0.04                  |<br/>| JDR          | 2014-09-14 00:00:00 | 12.89         | 0.03                  |<br/>| JDR          | 2014-09-13 00:00:00 | 12.86         | NULL                  |<br/>+--------------+---------------------+---------------+-----------------------+<br/></div><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_related_info\"><b>Related information:</b></p><p>\n        This function is the converse of <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_analytic_functions.xml#lead\"><h4>LEAD Function</h4></a>.\n      </p></div></div><div id=\"../Impala/docs/topics/impala_analytic_functions.xml_last_value\"><h4>LAST_VALUE Function</h4><div><p>\n        Returns the expression value from the last row in the window. This same value is repeated for all result\n        rows for the group. The return value is <span class=\"sql-docs-inline-code\">NULL</span> if the input expression is\n        <span class=\"sql-docs-inline-code\">NULL</span>.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_syntax_blurb\"><b>Syntax:</b></p><div class=\"sql-docs-code-block\">LAST_VALUE(<span class=\"sql-docs-variable\">expr</span>) OVER([<span class=\"sql-docs-variable\">partition_by_clause</span>] <span class=\"sql-docs-variable\">order_by_clause</span> [<span class=\"sql-docs-variable\">window_clause</span>])</div><p>\n        The <span class=\"sql-docs-inline-code\">PARTITION BY</span> clause is optional. The <span class=\"sql-docs-inline-code\">ORDER BY</span> clause is required. The\n        window clause is optional.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_usage_notes_blurb\"><b>Usage notes:</b></p><p>\n        If any duplicate values occur in the tuples evaluated by the <span class=\"sql-docs-inline-code\">ORDER BY</span> clause, the result\n        of this function is not deterministic. Consider adding additional <span class=\"sql-docs-inline-code\">ORDER BY</span> columns to\n        ensure consistent ordering.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_added_in_20\"><b>Added in:</b>Impala 2.0.0</p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_example_blurb\"><b>Examples:</b></p><p>\n        The following example uses the same <span class=\"sql-docs-inline-code\">MAIL_MERGE</span> table as in the example for\n        <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_analytic_functions.xml#first_value\"><h4>FIRST_VALUE Function</h4></a>. Because the default window when <span class=\"sql-docs-inline-code\">ORDER\n        BY</span> is used is <span class=\"sql-docs-inline-code\">BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</span>, the query requires the\n        <span class=\"sql-docs-inline-code\">UNBOUNDED FOLLOWING</span> to look ahead to subsequent rows and find the last value for each\n        country.\n      </p><div class=\"sql-docs-code-block\">select country, name,<br/>  last_value(greeting) over (<br/>    partition by country order by name, greeting<br/>    rows between unbounded preceding and unbounded following<br/>  ) as greeting<br/>  from mail_merge<br/>+---------+---------+--------------+<br/>| country | name    | greeting     |<br/>+---------+---------+--------------+<br/>| Germany | Boris   | Guten morgen |<br/>| Germany | Michael | Guten morgen |<br/>| Sweden  | Bjorn   | Tja          |<br/>| Sweden  | Mats    | Tja          |<br/>| USA     | John    | Hello        |<br/>| USA     | Pete    | Hello        |<br/>+---------+---------+--------------+<br/></div><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_related_info\"><b>Related information:</b></p><p><a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_analytic_functions.xml#first_value\"><h4>FIRST_VALUE Function</h4></a></p></div></div><div id=\"../Impala/docs/topics/impala_analytic_functions.xml_lead\"><h4>LEAD Function</h4><div><p>\n        This function returns the value of an expression using column values from a following row. You specify an\n        integer offset, which designates a row position some number of rows after to the current row. Any column\n        references in the expression argument refer to column values from that later row. Typically, the table\n        contains a time sequence or numeric sequence column that clearly distinguishes the ordering of the rows.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_syntax_blurb\"><b>Syntax:</b></p><div class=\"sql-docs-code-block\">LEAD (<span class=\"sql-docs-variable\">expr</span> [, <span class=\"sql-docs-variable\">offset</span>] [, <span class=\"sql-docs-variable\">default</span>])<br/>  OVER ([<span class=\"sql-docs-variable\">partition_by_clause</span>] <span class=\"sql-docs-variable\">order_by_clause</span>)</div><p>\n        The <span class=\"sql-docs-inline-code\">ORDER BY</span> clause is required. The <span class=\"sql-docs-inline-code\">PARTITION BY</span> clause is optional. The\n        window clause is not allowed.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_usage_notes_blurb\"><b>Usage notes:</b></p><p>\n        Sometimes used an an alternative to doing a self-join.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_added_in_20\"><b>Added in:</b>Impala 2.0.0</p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_example_blurb\"><b>Examples:</b></p><p>\n        The following example uses the same stock data created in <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_analytic_functions.xml#window_clause\"><h4>Window Clause</h4></a>. The query analyzes\n        the closing price for a stock symbol, and for each day evaluates if the closing price for the following day\n        is higher or lower.\n      </p><div class=\"sql-docs-code-block\">select stock_symbol, closing_date, closing_price,<br/>  case<br/>    (lead(closing_price,1)<br/>      over (partition by stock_symbol order by closing_date)<br/>        - closing_price) > 0<br/>    when true then \"higher\"<br/>    when false then \"flat or lower\"<br/>  end as \"trending\"<br/>from stock_ticker<br/>  order by closing_date;<br/>+--------------+---------------------+---------------+---------------+<br/>| stock_symbol | closing_date        | closing_price | trending      |<br/>+--------------+---------------------+---------------+---------------+<br/>| JDR          | 2014-09-13 00:00:00 | 12.86         | higher        |<br/>| JDR          | 2014-09-14 00:00:00 | 12.89         | higher        |<br/>| JDR          | 2014-09-15 00:00:00 | 12.94         | flat or lower |<br/>| JDR          | 2014-09-16 00:00:00 | 12.55         | higher        |<br/>| JDR          | 2014-09-17 00:00:00 | 14.03         | higher        |<br/>| JDR          | 2014-09-18 00:00:00 | 14.75         | flat or lower |<br/>| JDR          | 2014-09-19 00:00:00 | 13.98         | NULL          |<br/>+--------------+---------------------+---------------+---------------+<br/></div><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_related_info\"><b>Related information:</b></p><p>\n        This function is the converse of <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_analytic_functions.xml#lag\"><h4>LAG Function</h4></a>.\n      </p></div></div><div id=\"../Impala/docs/topics/impala_analytic_functions.xml_max_analytic\"><h4>MAX Function - Analytic Context</h4><div><p>\n        You can include an <span class=\"sql-docs-inline-code\">OVER</span> clause with a call to this function to use it as an analytic\n        function. See <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_max.xml#max\">MAX Function</a> for details and examples.\n      </p></div></div><div id=\"../Impala/docs/topics/impala_analytic_functions.xml_min_analytic\"><h4>MIN Function - Analytic Context</h4><div><p>\n        You can include an <span class=\"sql-docs-inline-code\">OVER</span> clause with a call to this function to use it as an analytic\n        function. See <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_min.xml#min\">MIN Function</a> for details and examples.\n      </p></div></div><div id=\"../Impala/docs/topics/impala_analytic_functions.xml_ntile\"><h4>NTILE Function (Impala 2.3 or higher only)</h4><div><p>\n        Returns the <q>bucket number</q> associated with each row, between 1 and the value of an expression. For\n        example, creating 100 buckets puts the lowest 1% of values in the first bucket, while creating 10 buckets\n        puts the lowest 10% of values in the first bucket. Each partition can have a different number of buckets.\n</p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_syntax_blurb\"><b>Syntax:</b></p><div class=\"sql-docs-code-block\">NTILE (<span class=\"sql-docs-variable\">expr</span> [, <span class=\"sql-docs-variable\">offset</span> ...]<br/>  OVER ([<span class=\"sql-docs-variable\">partition_by_clause</span>] <span class=\"sql-docs-variable\">order_by_clause</span>)</div><p>\n        The <span class=\"sql-docs-inline-code\">ORDER BY</span> clause is required. The <span class=\"sql-docs-inline-code\">PARTITION BY</span> clause is optional. The\n        window clause is not allowed.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_usage_notes_blurb\"><b>Usage notes:</b></p><p>\n        The <q>ntile</q> name is derived from the practice of dividing result sets into fourths (quartile), tenths\n        (decile), and so on. The <span class=\"sql-docs-inline-code\">NTILE()</span> function divides the result set based on an arbitrary\n        percentile value.\n      </p><p>\n        The number of buckets must be a positive integer.\n      </p><p>\n        The number of items in each bucket is identical or almost so, varying by at most 1. If the number of items\n        does not divide evenly between the buckets, the remaining N items are divided evenly among the first N\n        buckets.\n      </p><p>\n        If the number of buckets N is greater than the number of input rows in the partition, then the first N\n        buckets each contain one item, and the remaining buckets are empty.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_example_blurb\"><b>Examples:</b></p><p>\n        The following example shows divides groups of animals into 4 buckets based on their weight. The\n        <span class=\"sql-docs-inline-code\">ORDER BY ... DESC</span> clause in the <span class=\"sql-docs-inline-code\">OVER()</span> clause means that the heaviest 25%\n        are in the first group, and the lightest 25% are in the fourth group. (The <span class=\"sql-docs-inline-code\">ORDER BY</span> in the\n        outermost part of the query shows how you can order the final result set independently from the order in\n        which the rows are evaluated by the <span class=\"sql-docs-inline-code\">OVER()</span> clause.) Because there are 9 rows in the group,\n        divided into 4 buckets, the first bucket receives the extra item.\n      </p><div class=\"sql-docs-code-block\">create table animals (name string, kind string, kilos decimal(9,3));<br/><br/>insert into animals values<br/>  ('Elephant', 'Mammal', 4000), ('Giraffe', 'Mammal', 1200), ('Mouse', 'Mammal', 0.020),<br/>  ('Condor', 'Bird', 15), ('Horse', 'Mammal', 500), ('Owl', 'Bird', 2.5),<br/>  ('Ostrich', 'Bird', 145), ('Polar bear', 'Mammal', 700), ('Housecat', 'Mammal', 5);<br/><br/>select name, ntile(4) over (order by kilos desc) as quarter<br/>  from animals<br/>order by quarter desc;<br/>+------------+---------+<br/>| name       | quarter |<br/>+------------+---------+<br/>| Owl        | 4       |<br/>| Mouse      | 4       |<br/>| Condor     | 3       |<br/>| Housecat   | 3       |<br/>| Horse      | 2       |<br/>| Ostrich    | 2       |<br/>| Elephant   | 1       |<br/>| Giraffe    | 1       |<br/>| Polar bear | 1       |<br/>+------------+---------+<br/></div><p>\n        The following examples show how the <span class=\"sql-docs-inline-code\">PARTITION</span> clause works for the\n        <span class=\"sql-docs-inline-code\">NTILE()</span> function. Here, we divide each kind of animal (mammal or bird) into 2 buckets,\n        the heavier half and the lighter half.\n      </p><div class=\"sql-docs-code-block\">select name, kind, ntile(2) over (partition by kind order by kilos desc) as half<br/>  from animals<br/>order by kind;<br/>+------------+--------+------+<br/>| name       | kind   | half |<br/>+------------+--------+------+<br/>| Ostrich    | Bird   | 1    |<br/>| Condor     | Bird   | 1    |<br/>| Owl        | Bird   | 2    |<br/>| Elephant   | Mammal | 1    |<br/>| Giraffe    | Mammal | 1    |<br/>| Polar bear | Mammal | 1    |<br/>| Horse      | Mammal | 2    |<br/>| Housecat   | Mammal | 2    |<br/>| Mouse      | Mammal | 2    |<br/>+------------+--------+------+<br/></div><p>\n        Again, the result set can be ordered independently\n        from the analytic evaluation. This next example lists all the animals heaviest to lightest,\n        showing that elephant and giraffe are in the <q>top half</q> of mammals by weight, while\n        housecat and mouse are in the <q>bottom half</q>.\n      </p><div class=\"sql-docs-code-block\">select name, kind, ntile(2) over (partition by kind order by kilos desc) as half<br/>  from animals<br/>order by kilos desc;<br/>+------------+--------+------+<br/>| name       | kind   | half |<br/>+------------+--------+------+<br/>| Elephant   | Mammal | 1    |<br/>| Giraffe    | Mammal | 1    |<br/>| Polar bear | Mammal | 1    |<br/>| Horse      | Mammal | 2    |<br/>| Ostrich    | Bird   | 1    |<br/>| Condor     | Bird   | 1    |<br/>| Housecat   | Mammal | 2    |<br/>| Owl        | Bird   | 2    |<br/>| Mouse      | Mammal | 2    |<br/>+------------+--------+------+<br/></div></div></div><div id=\"../Impala/docs/topics/impala_analytic_functions.xml_percent_rank\"><h4>PERCENT_RANK Function (Impala 2.3 or higher only)</h4><div><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_syntax_blurb\"><b>Syntax:</b></p><div class=\"sql-docs-code-block\">PERCENT_RANK (<span class=\"sql-docs-variable\">expr</span>)<br/>  OVER ([<span class=\"sql-docs-variable\">partition_by_clause</span>] <span class=\"sql-docs-variable\">order_by_clause</span>)<br/></div><p>\n      Calculates the rank, expressed as a percentage, of each row within a group of rows.\n      If <span class=\"sql-docs-inline-code\">rank</span> is the value for that same row from the <span class=\"sql-docs-inline-code\">RANK()</span> function (from 1 to the total number of rows in the partition group),\n      then the <span class=\"sql-docs-inline-code\">PERCENT_RANK()</span> value is calculated as <span class=\"sql-docs-inline-code\">(<span class=\"sql-docs-variable\">rank</span> - 1) / (<span class=\"sql-docs-variable\">rows_in_group</span> - 1)</span> .\n      If there is only a single item in the partition group, its <span class=\"sql-docs-inline-code\">PERCENT_RANK()</span> value is 0.\n      </p><p>\n        The <span class=\"sql-docs-inline-code\">ORDER BY</span> clause is required. The <span class=\"sql-docs-inline-code\">PARTITION BY</span> clause is optional. The\n        window clause is not allowed.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_usage_notes_blurb\"><b>Usage notes:</b></p><p>\n        This function is similar to the <span class=\"sql-docs-inline-code\">RANK</span> and <span class=\"sql-docs-inline-code\">CUME_DIST()</span> functions: it returns an ascending sequence representing the position of each\n        row within the rows of the same partition group. The actual numeric sequence is calculated differently,\n        and the handling of duplicate (tied) values is different.\n      </p><p>\n        The return values range from 0 to 1 inclusive.\n        The first row in each partition group always has the value 0.\n        A <span class=\"sql-docs-inline-code\">NULL</span> value is considered the lowest possible value.\n        In the case of duplicate input values, all the corresponding rows in the result set\n        have an identical value: the lowest <span class=\"sql-docs-inline-code\">PERCENT_RANK()</span> value of those\n        tied rows. (In contrast to <span class=\"sql-docs-inline-code\">CUME_DIST()</span>, where all tied rows have\n        the highest <span class=\"sql-docs-inline-code\">CUME_DIST()</span> value.)\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_example_blurb\"><b>Examples:</b></p><p>\n        The following example uses the same <span class=\"sql-docs-inline-code\">ANIMALS</span> table as the examples for <span class=\"sql-docs-inline-code\">CUME_DIST()</span>\n        and <span class=\"sql-docs-inline-code\">NTILE()</span>, with a few additional rows to illustrate the results where some values are\n        <span class=\"sql-docs-inline-code\">NULL</span> or there is only a single row in a partition group.\n      </p><div class=\"sql-docs-code-block\">insert into animals values ('Komodo dragon', 'Reptile', 70);<br/>insert into animals values ('Unicorn', 'Mythical', NULL);<br/>insert into animals values ('Fire-breathing dragon', 'Mythical', NULL);<br/></div><p>\n        As with <span class=\"sql-docs-inline-code\">CUME_DIST()</span>, there is an ascending sequence for each kind of animal.\n        For example, the <q>Birds</q> and <q>Mammals</q> rows each have a <span class=\"sql-docs-inline-code\">PERCENT_RANK()</span> sequence\n        that ranges from 0 to 1.\n        The <q>Reptile</q> row has a <span class=\"sql-docs-inline-code\">PERCENT_RANK()</span> of 0 because that partition group contains only a single item.\n        Both <q>Mythical</q> animals have a <span class=\"sql-docs-inline-code\">PERCENT_RANK()</span> of 0 because\n        a <span class=\"sql-docs-inline-code\">NULL</span> is considered the lowest value within its partition group.\n      </p><div class=\"sql-docs-code-block\">select name, kind, percent_rank() over (partition by kind order by kilos) from animals;<br/>+-----------------------+----------+--------------------------+<br/>| name                  | kind     | percent_rank() OVER(...) |<br/>+-----------------------+----------+--------------------------+<br/>| Mouse                 | Mammal   | 0                        |<br/>| Housecat              | Mammal   | 0.2                      |<br/>| Horse                 | Mammal   | 0.4                      |<br/>| Polar bear            | Mammal   | 0.6                      |<br/>| Giraffe               | Mammal   | 0.8                      |<br/>| Elephant              | Mammal   | 1                        |<br/>| Komodo dragon         | Reptile  | 0                        |<br/>| Owl                   | Bird     | 0                        |<br/>| California Condor     | Bird     | 0.25                     |<br/>| Andean Condor         | Bird     | 0.25                     |<br/>| Condor                | Bird     | 0.25                     |<br/>| Ostrich               | Bird     | 1                        |<br/>| Fire-breathing dragon | Mythical | 0                        |<br/>| Unicorn               | Mythical | 0                        |<br/>+-----------------------+----------+--------------------------+<br/></div></div></div><div id=\"../Impala/docs/topics/impala_analytic_functions.xml_rank\"><h4>RANK Function</h4><div><p>\n        Returns an ascending sequence of integers, starting with 1. The output sequence produces duplicate integers\n        for duplicate values of the <span class=\"sql-docs-inline-code\">ORDER BY</span> expressions. After generating duplicate output values\n        for the <q>tied</q> input values, the function increments the sequence by the number of tied values.\n        Therefore, the sequence contains both duplicates and gaps when the input contains duplicates. Starts the\n        sequence over for each group produced by the <span class=\"sql-docs-inline-code\">PARTITIONED BY</span> clause.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_syntax_blurb\"><b>Syntax:</b></p><div class=\"sql-docs-code-block\">RANK() OVER([<span class=\"sql-docs-variable\">partition_by_clause</span>] <span class=\"sql-docs-variable\">order_by_clause</span>)</div><p>\n        The <span class=\"sql-docs-inline-code\">PARTITION BY</span> clause is optional. The <span class=\"sql-docs-inline-code\">ORDER BY</span> clause is required. The\n        window clause is not allowed.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_usage_notes_blurb\"><b>Usage notes:</b></p><p>\n        Often used for top-N and bottom-N queries. For example, it could produce a <q>top 10</q> report including\n        several items that were tied for 10th place.\n      </p><p>\n        Similar to <span class=\"sql-docs-inline-code\">ROW_NUMBER</span> and <span class=\"sql-docs-inline-code\">DENSE_RANK</span>. These functions differ in how they\n        treat duplicate combinations of values.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_added_in_20\"><b>Added in:</b>Impala 2.0.0</p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_example_blurb\"><b>Examples:</b></p><p>\n        The following example demonstrates how the <span class=\"sql-docs-inline-code\">RANK()</span> function identifies where each value\n        <q>places</q> in the result set, producing the same result for duplicate values, and skipping values in the\n        sequence to account for the number of duplicates. For example, when results are ordered by the\n        <span class=\"sql-docs-inline-code\">X</span> column, both <span class=\"sql-docs-inline-code\">1</span> values are tied for first; both <span class=\"sql-docs-inline-code\">2</span>\n        values are tied for third; and so on.\n      </p><div class=\"sql-docs-code-block\">select x, rank() over(order by x) as rank, property from int_t;<br/>+----+------+----------+<br/>| x  | rank | property |<br/>+----+------+----------+<br/>| 1  | 1    | square   |<br/>| 1  | 1    | odd      |<br/>| 2  | 3    | even     |<br/>| 2  | 3    | prime    |<br/>| 3  | 5    | prime    |<br/>| 3  | 5    | odd      |<br/>| 4  | 7    | even     |<br/>| 4  | 7    | square   |<br/>| 5  | 9    | odd      |<br/>| 5  | 9    | prime    |<br/>| 6  | 11   | even     |<br/>| 6  | 11   | perfect  |<br/>| 7  | 13   | lucky    |<br/>| 7  | 13   | lucky    |<br/>| 7  | 13   | lucky    |<br/>| 7  | 13   | odd      |<br/>| 7  | 13   | prime    |<br/>| 8  | 18   | even     |<br/>| 9  | 19   | square   |<br/>| 9  | 19   | odd      |<br/>| 10 | 21   | round    |<br/>| 10 | 21   | even     |<br/>+----+------+----------+<br/></div><p>\n        The following examples show how the <span class=\"sql-docs-inline-code\">RANK()</span> function is affected by the\n        <span class=\"sql-docs-inline-code\">PARTITION</span> property within the <span class=\"sql-docs-inline-code\">ORDER BY</span> clause.\n      </p><p>\n        Partitioning by the <span class=\"sql-docs-inline-code\">PROPERTY</span> column groups all the even, odd, and so on values together,\n        and <span class=\"sql-docs-inline-code\">RANK()</span> returns the place of each value within the group, producing several ascending\n        sequences.\n      </p><div class=\"sql-docs-code-block\">select x, rank() over(partition by property order by x) as rank, property from int_t;<br/>+----+------+----------+<br/>| x  | rank | property |<br/>+----+------+----------+<br/>| 2  | 1    | even     |<br/>| 4  | 2    | even     |<br/>| 6  | 3    | even     |<br/>| 8  | 4    | even     |<br/>| 10 | 5    | even     |<br/>| 7  | 1    | lucky    |<br/>| 7  | 1    | lucky    |<br/>| 7  | 1    | lucky    |<br/>| 1  | 1    | odd      |<br/>| 3  | 2    | odd      |<br/>| 5  | 3    | odd      |<br/>| 7  | 4    | odd      |<br/>| 9  | 5    | odd      |<br/>| 6  | 1    | perfect  |<br/>| 2  | 1    | prime    |<br/>| 3  | 2    | prime    |<br/>| 5  | 3    | prime    |<br/>| 7  | 4    | prime    |<br/>| 10 | 1    | round    |<br/>| 1  | 1    | square   |<br/>| 4  | 2    | square   |<br/>| 9  | 3    | square   |<br/>+----+------+----------+<br/></div><p>\n        Partitioning by the <span class=\"sql-docs-inline-code\">X</span> column groups all the duplicate numbers together and returns the\n        place each value within the group; because each value occurs only 1 or 2 times,\n        <span class=\"sql-docs-inline-code\">RANK()</span> designates each <span class=\"sql-docs-inline-code\">X</span> value as either first or second within its\n        group.\n      </p><div class=\"sql-docs-code-block\">select x, rank() over(partition by x order by property) as rank, property from int_t;<br/>+----+------+----------+<br/>| x  | rank | property |<br/>+----+------+----------+<br/>| 1  | 1    | odd      |<br/>| 1  | 2    | square   |<br/>| 2  | 1    | even     |<br/>| 2  | 2    | prime    |<br/>| 3  | 1    | odd      |<br/>| 3  | 2    | prime    |<br/>| 4  | 1    | even     |<br/>| 4  | 2    | square   |<br/>| 5  | 1    | odd      |<br/>| 5  | 2    | prime    |<br/>| 6  | 1    | even     |<br/>| 6  | 2    | perfect  |<br/>| 7  | 1    | lucky    |<br/>| 7  | 1    | lucky    |<br/>| 7  | 1    | lucky    |<br/>| 7  | 4    | odd      |<br/>| 7  | 5    | prime    |<br/>| 8  | 1    | even     |<br/>| 9  | 1    | odd      |<br/>| 9  | 2    | square   |<br/>| 10 | 1    | even     |<br/>| 10 | 2    | round    |<br/>+----+------+----------+<br/></div><p>\n        The following example shows how a magazine might prepare a list of history's wealthiest people. Croesus and\n        Midas are tied for second, then Crassus is fourth.\n      </p><div class=\"sql-docs-code-block\">select rank() over (order by net_worth desc) as rank, name, net_worth from wealth order by rank, name;<br/>+------+---------+---------------+<br/>| rank | name    | net_worth     |<br/>+------+---------+---------------+<br/>| 1    | Solomon | 2000000000.00 |<br/>| 2    | Croesus | 1000000000.00 |<br/>| 2    | Midas   | 1000000000.00 |<br/>| 4    | Crassus | 500000000.00  |<br/>| 5    | Scrooge | 80000000.00   |<br/>+------+---------+---------------+<br/></div><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_related_info\"><b>Related information:</b></p><p><a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_analytic_functions.xml#dense_rank\"><h4>DENSE_RANK Function</h4></a>,\n        <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_analytic_functions.xml#row_number\"><h4>ROW_NUMBER Function</h4></a></p></div></div><div id=\"../Impala/docs/topics/impala_analytic_functions.xml_row_number\"><h4>ROW_NUMBER Function</h4><div><p>\n        Returns an ascending sequence of integers, starting with 1. Starts the sequence over for each group\n        produced by the <span class=\"sql-docs-inline-code\">PARTITIONED BY</span> clause. The output sequence includes different values for\n        duplicate input values. Therefore, the sequence never contains any duplicates or gaps, regardless of\n        duplicate input values.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_syntax_blurb\"><b>Syntax:</b></p><div class=\"sql-docs-code-block\">ROW_NUMBER() OVER([<span class=\"sql-docs-variable\">partition_by_clause</span>] <span class=\"sql-docs-variable\">order_by_clause</span>)</div><p>\n        The <span class=\"sql-docs-inline-code\">ORDER BY</span> clause is required. The <span class=\"sql-docs-inline-code\">PARTITION BY</span> clause is optional. The\n        window clause is not allowed.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_usage_notes_blurb\"><b>Usage notes:</b></p><p>\n        Often used for top-N and bottom-N queries where the input values are known to be unique, or precisely N\n        rows are needed regardless of duplicate values.\n      </p><p>\n        Because its result value is different for each row in the result set (when used without a <span class=\"sql-docs-inline-code\">PARTITION\n        BY</span> clause), <span class=\"sql-docs-inline-code\">ROW_NUMBER()</span> can be used to synthesize unique numeric ID values, for\n        example for result sets involving unique values or tuples.\n      </p><p>\n        Similar to <span class=\"sql-docs-inline-code\">RANK</span> and <span class=\"sql-docs-inline-code\">DENSE_RANK</span>. These functions differ in how they treat\n        duplicate combinations of values.\n      </p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_added_in_20\"><b>Added in:</b>Impala 2.0.0</p><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_example_blurb\"><b>Examples:</b></p><p>\n        The following example demonstrates how <span class=\"sql-docs-inline-code\">ROW_NUMBER()</span> produces a continuous numeric\n        sequence, even though some values of <span class=\"sql-docs-inline-code\">X</span> are repeated.\n      </p><div class=\"sql-docs-code-block\">select x, row_number() over(order by x, property) as row_number, property from int_t;<br/>+----+------------+----------+<br/>| x  | row_number | property |<br/>+----+------------+----------+<br/>| 1  | 1          | odd      |<br/>| 1  | 2          | square   |<br/>| 2  | 3          | even     |<br/>| 2  | 4          | prime    |<br/>| 3  | 5          | odd      |<br/>| 3  | 6          | prime    |<br/>| 4  | 7          | even     |<br/>| 4  | 8          | square   |<br/>| 5  | 9          | odd      |<br/>| 5  | 10         | prime    |<br/>| 6  | 11         | even     |<br/>| 6  | 12         | perfect  |<br/>| 7  | 13         | lucky    |<br/>| 7  | 14         | lucky    |<br/>| 7  | 15         | lucky    |<br/>| 7  | 16         | odd      |<br/>| 7  | 17         | prime    |<br/>| 8  | 18         | even     |<br/>| 9  | 19         | odd      |<br/>| 9  | 20         | square   |<br/>| 10 | 21         | even     |<br/>| 10 | 22         | round    |<br/>+----+------------+----------+<br/></div><p>\n        The following example shows how a financial institution might assign customer IDs to some of history's\n        wealthiest figures. Although two of the people have identical net worth figures, unique IDs are required\n        for this purpose. <span class=\"sql-docs-inline-code\">ROW_NUMBER()</span> produces a sequence of five different values for the five\n        input rows.\n      </p><div class=\"sql-docs-code-block\">select row_number() over (order by net_worth desc) as account_id, name, net_worth<br/>  from wealth order by account_id, name;<br/>+------------+---------+---------------+<br/>| account_id | name    | net_worth     |<br/>+------------+---------+---------------+<br/>| 1          | Solomon | 2000000000.00 |<br/>| 2          | Croesus | 1000000000.00 |<br/>| 3          | Midas   | 1000000000.00 |<br/>| 4          | Crassus | 500000000.00  |<br/>| 5          | Scrooge | 80000000.00   |<br/>+------------+---------+---------------+<br/></div><p id=\"../Impala/docs/topics/impala_analytic_functions.xml_related_info\"><b>Related information:</b></p><p><a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_analytic_functions.xml#rank\"><h4>RANK Function</h4></a>, <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_analytic_functions.xml#dense_rank\"><h4>DENSE_RANK Function</h4></a></p></div></div><div id=\"../Impala/docs/topics/impala_analytic_functions.xml_sum_analytic\"><h4>SUM Function - Analytic Context</h4><div><p>\n        You can include an <span class=\"sql-docs-inline-code\">OVER</span> clause with a call to this function to use it as an analytic\n        function. See <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_sum.xml#sum\">SUM Function</a> for details and examples.\n      </p></div></div>","title":"Impala Analytic Functions"}