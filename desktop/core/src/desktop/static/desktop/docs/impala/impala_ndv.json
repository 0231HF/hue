{"body":"<div><p>\n      An aggregate function that returns an approximate value similar to the result of <span class=\"sql-docs-inline-code\">COUNT(DISTINCT\n      <span class=\"sql-docs-variable\">col</span>)</span>, the <q>number of distinct values</q>. It is much faster than the\n      combination of <span class=\"sql-docs-inline-code\">COUNT</span> and <span class=\"sql-docs-inline-code\">DISTINCT</span>, and uses a constant amount of memory and\n      thus is less memory-intensive for columns with high cardinality.\n    </p><p id=\"../Impala/docs/topics/impala_ndv.xml_syntax_blurb\"><b>Syntax:</b></p><div class=\"sql-docs-code-block\">NDV([DISTINCT | ALL] <span class=\"sql-docs-variable\">expression</span>)</div><p id=\"../Impala/docs/topics/impala_ndv.xml_usage_notes_blurb\"><b>Usage notes:</b></p><p>\n      This is the mechanism used internally by the <span class=\"sql-docs-inline-code\">COMPUTE STATS</span> statement for computing the\n      number of distinct values in a column.\n    </p><p>\n      Because this number is an estimate, it might not reflect the precise number of different values in the\n      column, especially if the cardinality is very low or very high. If the estimated number is higher than the\n      number of rows in the table, Impala adjusts the value internally during query planning.\n    </p><p id=\"../Impala/docs/topics/impala_ndv.xml_former_odd_return_type_string\"><b>Return type:</b><span class=\"sql-docs-inline-code\">DOUBLE</span> in Impala 2.0 and higher; <span class=\"sql-docs-inline-code\">STRING</span> in earlier\n        releases\n      </p><p id=\"../Impala/docs/topics/impala_ndv.xml_complex_types_blurb\"><b>Complex type considerations:</b></p><p id=\"../Impala/docs/topics/impala_ndv.xml_complex_types_aggregation_explanation\">\n        To access a column with a complex type (<span class=\"sql-docs-inline-code\">ARRAY</span>, <span class=\"sql-docs-inline-code\">STRUCT</span>, or <span class=\"sql-docs-inline-code\">MAP</span>)\n        in an aggregation function, you unpack the individual elements using join notation in the query,\n        and then apply the function to the final scalar item, field, key, or value at the bottom of any nested type hierarchy in the column.\n        See <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_complex_types.xml#complex_types\">Complex Types (Impala 2.3 or higher only)</a> for details about using complex types in Impala.\n      </p><p id=\"../Impala/docs/topics/impala_ndv.xml_complex_types_aggregation_example\">\nThe following example demonstrates calls to several aggregation functions\nusing values from a column containing nested complex types\n(an <span class=\"sql-docs-inline-code\">ARRAY</span> of <span class=\"sql-docs-inline-code\">STRUCT</span> items).\nThe array is unpacked inside the query using join notation.\nThe array elements are referenced using the <span class=\"sql-docs-inline-code\">ITEM</span>\npseudocolumn, and the structure fields inside the array elements\nare referenced using dot notation.\nNumeric values such as <span class=\"sql-docs-inline-code\">SUM()</span> and <span class=\"sql-docs-inline-code\">AVG()</span>\nare computed using the numeric <span class=\"sql-docs-inline-code\">R_NATIONKEY</span> field, and\nthe general-purpose <span class=\"sql-docs-inline-code\">MAX()</span> and <span class=\"sql-docs-inline-code\">MIN()</span>\nvalues are computed from the string <span class=\"sql-docs-inline-code\">N_NAME</span> field.\n<div class=\"sql-docs-code-block\">describe region;<br/>+-------------+-------------------------+---------+<br/>| name        | type                    | comment |<br/>+-------------+-------------------------+---------+<br/>| r_regionkey | smallint                |         |<br/>| r_name      | string                  |         |<br/>| r_comment   | string                  |         |<br/>| r_nations   | array<struct<           |         |<br/>|             |   n_nationkey:smallint, |         |<br/>|             |   n_name:string,        |         |<br/>|             |   n_comment:string      |         |<br/>|             | >>                      |         |<br/>+-------------+-------------------------+---------+<br/><br/>select r_name, r_nations.item.n_nationkey<br/>  from region, region.r_nations as r_nations<br/>order by r_name, r_nations.item.n_nationkey;<br/>+-------------+------------------+<br/>| r_name      | item.n_nationkey |<br/>+-------------+------------------+<br/>| AFRICA      | 0                |<br/>| AFRICA      | 5                |<br/>| AFRICA      | 14               |<br/>| AFRICA      | 15               |<br/>| AFRICA      | 16               |<br/>| AMERICA     | 1                |<br/>| AMERICA     | 2                |<br/>| AMERICA     | 3                |<br/>| AMERICA     | 17               |<br/>| AMERICA     | 24               |<br/>| ASIA        | 8                |<br/>| ASIA        | 9                |<br/>| ASIA        | 12               |<br/>| ASIA        | 18               |<br/>| ASIA        | 21               |<br/>| EUROPE      | 6                |<br/>| EUROPE      | 7                |<br/>| EUROPE      | 19               |<br/>| EUROPE      | 22               |<br/>| EUROPE      | 23               |<br/>| MIDDLE EAST | 4                |<br/>| MIDDLE EAST | 10               |<br/>| MIDDLE EAST | 11               |<br/>| MIDDLE EAST | 13               |<br/>| MIDDLE EAST | 20               |<br/>+-------------+------------------+<br/><br/>select<br/>  r_name,<br/>  count(r_nations.item.n_nationkey) as count,<br/>  sum(r_nations.item.n_nationkey) as sum,<br/>  avg(r_nations.item.n_nationkey) as avg,<br/>  min(r_nations.item.n_name) as minimum,<br/>  max(r_nations.item.n_name) as maximum,<br/>  ndv(r_nations.item.n_nationkey) as distinct_vals<br/>from<br/>  region, region.r_nations as r_nations<br/>group by r_name<br/>order by r_name;<br/>+-------------+-------+-----+------+-----------+----------------+---------------+<br/>| r_name      | count | sum | avg  | minimum   | maximum        | distinct_vals |<br/>+-------------+-------+-----+------+-----------+----------------+---------------+<br/>| AFRICA      | 5     | 50  | 10   | ALGERIA   | MOZAMBIQUE     | 5             |<br/>| AMERICA     | 5     | 47  | 9.4  | ARGENTINA | UNITED STATES  | 5             |<br/>| ASIA        | 5     | 68  | 13.6 | CHINA     | VIETNAM        | 5             |<br/>| EUROPE      | 5     | 77  | 15.4 | FRANCE    | UNITED KINGDOM | 5             |<br/>| MIDDLE EAST | 5     | 58  | 11.6 | EGYPT     | SAUDI ARABIA   | 5             |<br/>+-------------+-------+-----+------+-----------+----------------+---------------+<br/></div></p><p id=\"../Impala/docs/topics/impala_ndv.xml_restrictions_blurb\"><b>Restrictions:</b></p><p id=\"../Impala/docs/topics/impala_ndv.xml_analytic_not_allowed_caveat\">\n        This function cannot be used in an analytic context. That is, the <span class=\"sql-docs-inline-code\">OVER()</span> clause is not allowed at all with this function.\n      </p><p id=\"../Impala/docs/topics/impala_ndv.xml_example_blurb\"><b>Examples:</b></p><p>\n      The following example queries a billion-row table to illustrate the relative performance of\n      <span class=\"sql-docs-inline-code\">COUNT(DISTINCT)</span> and <span class=\"sql-docs-inline-code\">NDV()</span>. It shows how <span class=\"sql-docs-inline-code\">COUNT(DISTINCT)</span>\n      gives a precise answer, but is inefficient for large-scale data where an approximate result is sufficient.\n      The <span class=\"sql-docs-inline-code\">NDV()</span> function gives an approximate result but is much faster.\n    </p><div class=\"sql-docs-code-block\">select count(distinct col1) from sample_data;<br/>+---------------------+<br/>| count(distinct col1)|<br/>+---------------------+<br/>| 100000              |<br/>+---------------------+<br/>Fetched 1 row(s) in 20.13s<br/><br/>select cast(ndv(col1) as bigint) as col1 from sample_data;<br/>+----------+<br/>| col1     |<br/>+----------+<br/>| 139017   |<br/>+----------+<br/>Fetched 1 row(s) in 8.91s<br/></div><p>\n      The following example shows how you can code multiple <span class=\"sql-docs-inline-code\">NDV()</span> calls in a single query, to\n      easily learn which columns have substantially more or fewer distinct values. This technique is faster than\n      running a sequence of queries with <span class=\"sql-docs-inline-code\">COUNT(DISTINCT)</span> calls.\n    </p><div class=\"sql-docs-code-block\">select cast(ndv(col1) as bigint) as col1, cast(ndv(col2) as bigint) as col2,<br/>    cast(ndv(col3) as bigint) as col3, cast(ndv(col4) as bigint) as col4<br/>  from sample_data;<br/>+----------+-----------+------------+-----------+<br/>| col1     | col2      | col3       | col4      |<br/>+----------+-----------+------------+-----------+<br/>| 139017   | 282       | 46         | 145636240 |<br/>+----------+-----------+------------+-----------+<br/>Fetched 1 row(s) in 34.97s<br/><br/>select count(distinct col1) from sample_data;<br/>+---------------------+<br/>| count(distinct col1)|<br/>+---------------------+<br/>| 100000              |<br/>+---------------------+<br/>Fetched 1 row(s) in 20.13s<br/><br/>select count(distinct col2) from sample_data;<br/>+----------------------+<br/>| count(distinct col2) |<br/>+----------------------+<br/>| 278                  |<br/>+----------------------+<br/>Fetched 1 row(s) in 20.09s<br/><br/>select count(distinct col3) from sample_data;<br/>+-----------------------+<br/>| count(distinct col3)  |<br/>+-----------------------+<br/>| 46                    |<br/>+-----------------------+<br/>Fetched 1 row(s) in 19.12s<br/><br/>select count(distinct col4) from sample_data;<br/>+----------------------+<br/>| count(distinct col4) |<br/>+----------------------+<br/>| 147135880            |<br/>+----------------------+<br/>Fetched 1 row(s) in 266.95s<br/></div></div>","title":"NDV Function"}