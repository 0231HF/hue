{"body":"<div><p>\n      An aggregate function that returns the maximum value from a set of numbers. Opposite of the\n      <span class=\"sql-docs-inline-code\">MIN</span> function. Its single argument can be numeric column, or the numeric result of a function\n      or expression applied to the column value. Rows with a <span class=\"sql-docs-inline-code\">NULL</span> value for the specified column\n      are ignored. If the table is empty, or all the values supplied to <span class=\"sql-docs-inline-code\">MAX</span> are\n      <span class=\"sql-docs-inline-code\">NULL</span>, <span class=\"sql-docs-inline-code\">MAX</span> returns <span class=\"sql-docs-inline-code\">NULL</span>.\n    </p><p id=\"../Impala/docs/topics/impala_max.xml_syntax_blurb\"><b>Syntax:</b></p><div class=\"sql-docs-code-block\">MAX([DISTINCT | ALL] <span class=\"sql-docs-variable\">expression</span>) [OVER (<span class=\"sql-docs-variable\">analytic_clause</span>)]</div><p>\n      When the query contains a <span class=\"sql-docs-inline-code\">GROUP BY</span> clause, returns one value for each combination of\n      grouping values.\n    </p><p id=\"../Impala/docs/topics/impala_max.xml_restrictions_sliding_window\"><b>Restrictions:</b> In Impala 2.0 and higher, this function can be used as an analytic function, but with restrictions on any window clause.\n        For <span class=\"sql-docs-inline-code\">MAX()</span> and <span class=\"sql-docs-inline-code\">MIN()</span>, the window clause is only allowed if the start\n        bound is <span class=\"sql-docs-inline-code\">UNBOUNDED PRECEDING</span>.\n      </p><p id=\"../Impala/docs/topics/impala_max.xml_return_type_same_except_string\"><b>Return type:</b> Same as the input value, except for <span class=\"sql-docs-inline-code\">CHAR</span> and <span class=\"sql-docs-inline-code\">VARCHAR</span>\n        arguments which produce a <span class=\"sql-docs-inline-code\">STRING</span> result\n      </p><p id=\"../Impala/docs/topics/impala_max.xml_usage_notes_blurb\"><b>Usage notes:</b></p><p id=\"../Impala/docs/topics/impala_max.xml_partition_key_optimization\">\n        If you frequently run aggregate functions such as <span class=\"sql-docs-inline-code\">MIN()</span>, <span class=\"sql-docs-inline-code\">MAX()</span>, and\n        <span class=\"sql-docs-inline-code\">COUNT(DISTINCT)</span> on partition key columns, consider enabling the <span class=\"sql-docs-inline-code\">OPTIMIZE_PARTITION_KEY_SCANS</span>\n        query option, which optimizes such queries. This feature is available in Impala 2.5 and higher.\n        See <span>impala optimize partition key scans</span>\n        for the kinds of queries that this option applies to, and slight differences in how partitions are\n        evaluated when this query option is enabled.\n      </p><p id=\"../Impala/docs/topics/impala_max.xml_complex_types_blurb\"><b>Complex type considerations:</b></p><p id=\"../Impala/docs/topics/impala_max.xml_complex_types_aggregation_explanation\">\n        To access a column with a complex type (<span class=\"sql-docs-inline-code\">ARRAY</span>, <span class=\"sql-docs-inline-code\">STRUCT</span>, or <span class=\"sql-docs-inline-code\">MAP</span>)\n        in an aggregation function, you unpack the individual elements using join notation in the query,\n        and then apply the function to the final scalar item, field, key, or value at the bottom of any nested type hierarchy in the column.\n        See <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_complex_types.xml#complex_types\">Complex Types (Impala 2.3 or higher only)</a> for details about using complex types in Impala.\n      </p><p id=\"../Impala/docs/topics/impala_max.xml_complex_types_aggregation_example\">\nThe following example demonstrates calls to several aggregation functions\nusing values from a column containing nested complex types\n(an <span class=\"sql-docs-inline-code\">ARRAY</span> of <span class=\"sql-docs-inline-code\">STRUCT</span> items).\nThe array is unpacked inside the query using join notation.\nThe array elements are referenced using the <span class=\"sql-docs-inline-code\">ITEM</span>\npseudocolumn, and the structure fields inside the array elements\nare referenced using dot notation.\nNumeric values such as <span class=\"sql-docs-inline-code\">SUM()</span> and <span class=\"sql-docs-inline-code\">AVG()</span>\nare computed using the numeric <span class=\"sql-docs-inline-code\">R_NATIONKEY</span> field, and\nthe general-purpose <span class=\"sql-docs-inline-code\">MAX()</span> and <span class=\"sql-docs-inline-code\">MIN()</span>\nvalues are computed from the string <span class=\"sql-docs-inline-code\">N_NAME</span> field.\n<div class=\"sql-docs-code-block\">describe region;<br/>+-------------+-------------------------+---------+<br/>| name        | type                    | comment |<br/>+-------------+-------------------------+---------+<br/>| r_regionkey | smallint                |         |<br/>| r_name      | string                  |         |<br/>| r_comment   | string                  |         |<br/>| r_nations   | array<struct<           |         |<br/>|             |   n_nationkey:smallint, |         |<br/>|             |   n_name:string,        |         |<br/>|             |   n_comment:string      |         |<br/>|             | >>                      |         |<br/>+-------------+-------------------------+---------+<br/><br/>select r_name, r_nations.item.n_nationkey<br/>  from region, region.r_nations as r_nations<br/>order by r_name, r_nations.item.n_nationkey;<br/>+-------------+------------------+<br/>| r_name      | item.n_nationkey |<br/>+-------------+------------------+<br/>| AFRICA      | 0                |<br/>| AFRICA      | 5                |<br/>| AFRICA      | 14               |<br/>| AFRICA      | 15               |<br/>| AFRICA      | 16               |<br/>| AMERICA     | 1                |<br/>| AMERICA     | 2                |<br/>| AMERICA     | 3                |<br/>| AMERICA     | 17               |<br/>| AMERICA     | 24               |<br/>| ASIA        | 8                |<br/>| ASIA        | 9                |<br/>| ASIA        | 12               |<br/>| ASIA        | 18               |<br/>| ASIA        | 21               |<br/>| EUROPE      | 6                |<br/>| EUROPE      | 7                |<br/>| EUROPE      | 19               |<br/>| EUROPE      | 22               |<br/>| EUROPE      | 23               |<br/>| MIDDLE EAST | 4                |<br/>| MIDDLE EAST | 10               |<br/>| MIDDLE EAST | 11               |<br/>| MIDDLE EAST | 13               |<br/>| MIDDLE EAST | 20               |<br/>+-------------+------------------+<br/><br/>select<br/>  r_name,<br/>  count(r_nations.item.n_nationkey) as count,<br/>  sum(r_nations.item.n_nationkey) as sum,<br/>  avg(r_nations.item.n_nationkey) as avg,<br/>  min(r_nations.item.n_name) as minimum,<br/>  max(r_nations.item.n_name) as maximum,<br/>  ndv(r_nations.item.n_nationkey) as distinct_vals<br/>from<br/>  region, region.r_nations as r_nations<br/>group by r_name<br/>order by r_name;<br/>+-------------+-------+-----+------+-----------+----------------+---------------+<br/>| r_name      | count | sum | avg  | minimum   | maximum        | distinct_vals |<br/>+-------------+-------+-----+------+-----------+----------------+---------------+<br/>| AFRICA      | 5     | 50  | 10   | ALGERIA   | MOZAMBIQUE     | 5             |<br/>| AMERICA     | 5     | 47  | 9.4  | ARGENTINA | UNITED STATES  | 5             |<br/>| ASIA        | 5     | 68  | 13.6 | CHINA     | VIETNAM        | 5             |<br/>| EUROPE      | 5     | 77  | 15.4 | FRANCE    | UNITED KINGDOM | 5             |<br/>| MIDDLE EAST | 5     | 58  | 11.6 | EGYPT     | SAUDI ARABIA   | 5             |<br/>+-------------+-------+-----+------+-----------+----------------+---------------+<br/></div></p><p id=\"../Impala/docs/topics/impala_max.xml_example_blurb\"><b>Examples:</b></p><div class=\"sql-docs-code-block\">-- Find the largest value for this column in the table.<br/>select max(c1) from t1;<br/>-- Find the largest value for this column from a subset of the table.<br/>select max(c1) from t1 where month = 'January' and year = '2013';<br/>-- Find the largest value from a set of numeric function results.<br/>select max(length(s)) from t1;<br/>-- Can also be used in combination with DISTINCT and/or GROUP BY.<br/>-- Return more than one result.<br/>select month, year, max(purchase_price) from store_stats group by month, year;<br/>-- Filter the input to eliminate duplicates before performing the calculation.<br/>select max(distinct x) from t1;<br/></div><p>\n      The following examples show how to use <span class=\"sql-docs-inline-code\">MAX()</span> in an analytic context. They use a table\n      containing integers from 1 to 10. Notice how the <span class=\"sql-docs-inline-code\">MAX()</span> is reported for each input value, as\n      opposed to the <span class=\"sql-docs-inline-code\">GROUP BY</span> clause which condenses the result set.\n<div class=\"sql-docs-code-block\">select x, property, max(x) over (partition by property) as max from int_t where property in ('odd','even');<br/>+----+----------+-----+<br/>| x  | property | max |<br/>+----+----------+-----+<br/>| 2  | even     | 10  |<br/>| 4  | even     | 10  |<br/>| 6  | even     | 10  |<br/>| 8  | even     | 10  |<br/>| 10 | even     | 10  |<br/>| 1  | odd      | 9   |<br/>| 3  | odd      | 9   |<br/>| 5  | odd      | 9   |<br/>| 7  | odd      | 9   |<br/>| 9  | odd      | 9   |<br/>+----+----------+-----+<br/></div>\n\nAdding an <span class=\"sql-docs-inline-code\">ORDER BY</span> clause lets you experiment with results that are cumulative or apply to a moving\nset of rows (the <q>window</q>). The following examples use <span class=\"sql-docs-inline-code\">MAX()</span> in an analytic context\n(that is, with an <span class=\"sql-docs-inline-code\">OVER()</span> clause) to display the smallest value of <span class=\"sql-docs-inline-code\">X</span>\nencountered up to each row in the result set. The examples use two columns in the <span class=\"sql-docs-inline-code\">ORDER BY</span>\nclause to produce a sequence of values that rises and falls, to illustrate how the <span class=\"sql-docs-inline-code\">MAX()</span>\nresult only increases or stays the same throughout each partition within the result set.\nThe basic <span class=\"sql-docs-inline-code\">ORDER BY x</span> clause implicitly\nactivates a window clause of <span class=\"sql-docs-inline-code\">RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</span>,\nwhich is effectively the same as <span class=\"sql-docs-inline-code\">ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</span>,\ntherefore all of these examples produce the same results:\n\n<div class=\"sql-docs-code-block\">select x, property,<br/>  max(x) <b>over (order by property, x desc)</b> as 'maximum to this point'<br/>from int_t where property in ('prime','square');<br/>+---+----------+-----------------------+<br/>| x | property | maximum to this point |<br/>+---+----------+-----------------------+<br/>| 7 | prime    | 7                     |<br/>| 5 | prime    | 7                     |<br/>| 3 | prime    | 7                     |<br/>| 2 | prime    | 7                     |<br/>| 9 | square   | 9                     |<br/>| 4 | square   | 9                     |<br/>| 1 | square   | 9                     |<br/>+---+----------+-----------------------+<br/><br/>select x, property,<br/>  max(x) over<br/>  (<br/>    <b>order by property, x desc</b><b>rows between unbounded preceding and current row</b><br/>  ) as 'maximum to this point'<br/>from int_t where property in ('prime','square');<br/>+---+----------+-----------------------+<br/>| x | property | maximum to this point |<br/>+---+----------+-----------------------+<br/>| 7 | prime    | 7                     |<br/>| 5 | prime    | 7                     |<br/>| 3 | prime    | 7                     |<br/>| 2 | prime    | 7                     |<br/>| 9 | square   | 9                     |<br/>| 4 | square   | 9                     |<br/>| 1 | square   | 9                     |<br/>+---+----------+-----------------------+<br/><br/>select x, property,<br/>  max(x) over<br/>  (<br/>    <b>order by property, x desc</b><b>range between unbounded preceding and current row</b><br/>  ) as 'maximum to this point'<br/>from int_t where property in ('prime','square');<br/>+---+----------+-----------------------+<br/>| x | property | maximum to this point |<br/>+---+----------+-----------------------+<br/>| 7 | prime    | 7                     |<br/>| 5 | prime    | 7                     |<br/>| 3 | prime    | 7                     |<br/>| 2 | prime    | 7                     |<br/>| 9 | square   | 9                     |<br/>| 4 | square   | 9                     |<br/>| 1 | square   | 9                     |<br/>+---+----------+-----------------------+<br/></div>\n\nThe following examples show how to construct a moving window, with a running maximum taking into account all rows before\nand 1 row after the current row.\nBecause of a restriction in the Impala <span class=\"sql-docs-inline-code\">RANGE</span> syntax, this type of\nmoving window is possible with the <span class=\"sql-docs-inline-code\">ROWS BETWEEN</span> clause but not the <span class=\"sql-docs-inline-code\">RANGE BETWEEN</span> clause.\nBecause of an extra Impala restriction on the <span class=\"sql-docs-inline-code\">MAX()</span> and <span class=\"sql-docs-inline-code\">MIN()</span> functions in an\nanalytic context, the lower bound must be <span class=\"sql-docs-inline-code\">UNBOUNDED PRECEDING</span>.\n<div class=\"sql-docs-code-block\">select x, property,<br/>  max(x) over<br/>  (<br/>    <b>order by property, x</b><b>rows between unbounded preceding and 1 following</b><br/>  ) as 'local maximum'<br/>from int_t where property in ('prime','square');<br/>+---+----------+---------------+<br/>| x | property | local maximum |<br/>+---+----------+---------------+<br/>| 2 | prime    | 3             |<br/>| 3 | prime    | 5             |<br/>| 5 | prime    | 7             |<br/>| 7 | prime    | 7             |<br/>| 1 | square   | 7             |<br/>| 4 | square   | 9             |<br/>| 9 | square   | 9             |<br/>+---+----------+---------------+<br/><br/>-- Doesn't work because of syntax restriction on RANGE clause.<br/>select x, property,<br/>  max(x) over<br/>  (<br/>    <b>order by property, x</b><b>range between unbounded preceding and 1 following</b><br/>  ) as 'local maximum'<br/>from int_t where property in ('prime','square');<br/>ERROR: AnalysisException: RANGE is only supported with both the lower and upper bounds UNBOUNDED or one UNBOUNDED and the other CURRENT ROW.<br/></div></p><p id=\"../Impala/docs/topics/impala_max.xml_related_info\"><b>Related information:</b></p><p><a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_analytic_functions.xml#analytic_functions\">Impala Analytic Functions</a>, <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_min.xml#min\">MIN Function</a>,\n      <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_avg.xml#avg\">AVG Function</a></p></div>","title":"MAX Function"}