{"body":"<div><p>\n      A join query is a <span class=\"sql-docs-inline-code\">SELECT</span>  statement that combines data from two or more tables,\n      and returns a result set containing items from some or all of those tables. It is a way to\n      cross-reference and correlate related data that is organized into multiple tables, typically\n      using identifiers that are repeated in each of the joined tables.\n    </p> <p id=\"../Impala/docs/topics/impala_joins.xml_syntax_blurb\"><b>Syntax:</b> </p> <p id=\"../Impala/docs/topics/impala_joins.xml_join_types\">\n        Impala supports a wide variety of <span class=\"sql-docs-inline-code\">JOIN</span>  clauses. Left, right, semi, full, and outer joins\n        are supported in all Impala versions. The <span class=\"sql-docs-inline-code\">CROSS JOIN</span>  operator is available in Impala 1.2.2\n        and higher. During performance tuning, you can override the reordering of join clauses that Impala does\n        internally by including the keyword <span class=\"sql-docs-inline-code\">STRAIGHT_JOIN</span>  immediately after the\n        <span class=\"sql-docs-inline-code\">SELECT</span>  and any <span class=\"sql-docs-inline-code\">DISTINCT</span>  or <span class=\"sql-docs-inline-code\">ALL</span>  keywords.\n      </p> <div class=\"sql-docs-code-block\">SELECT <span class=\"sql-docs-variable\">select_list</span> FROM<br/>  <span class=\"sql-docs-variable\">table_or_subquery1</span> [INNER] JOIN <span class=\"sql-docs-variable\">table_or_subquery2</span> |<br/>  <span class=\"sql-docs-variable\">table_or_subquery1</span> {LEFT [OUTER] | RIGHT [OUTER] | FULL [OUTER]} JOIN <span class=\"sql-docs-variable\">table_or_subquery2</span> |<br/>  <span class=\"sql-docs-variable\">table_or_subquery1</span> {LEFT | RIGHT} SEMI JOIN <span class=\"sql-docs-variable\">table_or_subquery2</span> |<br/>  <span class=\"sql-docs-inline-code\"><span class=\"sql-docs-variable\">table_or_subquery1</span> {LEFT | RIGHT} ANTI JOIN <span class=\"sql-docs-variable\">table_or_subquery2</span> |</span> [ ON <span class=\"sql-docs-variable\">col1</span> = <span class=\"sql-docs-variable\">col2</span> [AND <span class=\"sql-docs-variable\">col3</span> = <span class=\"sql-docs-variable\">col4</span> ...] |<br/>      USING (<span class=\"sql-docs-variable\">col1</span> [, <span class=\"sql-docs-variable\">col2</span> ...]) ]<br/>  [<span class=\"sql-docs-variable\">other_join_clause</span> ...]<br/>[ WHERE <span class=\"sql-docs-variable\">where_clauses</span> ]<br/><br/>SELECT <span class=\"sql-docs-variable\">select_list</span> FROM<br/>  <span class=\"sql-docs-variable\">table_or_subquery1</span> , <span class=\"sql-docs-variable\">table_or_subquery2</span> [, <span class=\"sql-docs-variable\">table_or_subquery3</span> ...]<br/>  [<span class=\"sql-docs-variable\">other_join_clause</span> ...]<br/>WHERE<br/>    <span class=\"sql-docs-variable\">col1</span> = <span class=\"sql-docs-variable\">col2</span> [AND <span class=\"sql-docs-variable\">col3</span> = <span class=\"sql-docs-variable\">col4</span> ...]<br/><br/>SELECT <span class=\"sql-docs-variable\">select_list</span> FROM<br/>  <span class=\"sql-docs-variable\">table_or_subquery1</span> CROSS JOIN <span class=\"sql-docs-variable\">table_or_subquery2</span> [<span class=\"sql-docs-variable\">other_join_clause</span> ...]<br/>[ WHERE <span class=\"sql-docs-variable\">where_clauses</span> ]</div><p><b>SQL-92 and SQL-89 Joins:</b> </p> <p>\n      Queries with the explicit <span class=\"sql-docs-inline-code\">JOIN</span>  keywords are known as SQL-92 style joins, referring to the\n      level of the SQL standard where they were introduced. The corresponding <span class=\"sql-docs-inline-code\">ON</span>  or\n      <span class=\"sql-docs-inline-code\">USING</span>  clauses clearly show which columns are used as the join keys in each case:\n    </p> <div class=\"sql-docs-code-block\">SELECT t1.c1, t2.c2 FROM <b>t1 JOIN t2</b> <b>ON t1.id = t2.id and t1.type_flag = t2.type_flag</b> WHERE t1.c1 > 100;<br/><br/>SELECT t1.c1, t2.c2 FROM <b>t1 JOIN t2</b> <b>USING (id, type_flag)</b> WHERE t1.c1 > 100;</div><p>\n      The <span class=\"sql-docs-inline-code\">ON</span>  clause is a general way to compare columns across the two tables, even if the column\n      names are different. The <span class=\"sql-docs-inline-code\">USING</span>  clause is a shorthand notation for specifying the join\n      columns, when the column names are the same in both tables. You can code equivalent <span class=\"sql-docs-inline-code\">WHERE</span> \n      clauses that compare the columns, instead of <span class=\"sql-docs-inline-code\">ON</span>  or <span class=\"sql-docs-inline-code\">USING</span>  clauses, but that\n      practice is not recommended because mixing the join comparisons with other filtering clauses is typically\n      less readable and harder to maintain.\n    </p> <p>\n      Queries with a comma-separated list of tables and subqueries are known as SQL-89 style joins. In these\n      queries, the equality comparisons between columns of the joined tables go in the <span class=\"sql-docs-inline-code\">WHERE</span> \n      clause alongside other kinds of comparisons. This syntax is easy to learn, but it is also easy to\n      accidentally remove a <span class=\"sql-docs-inline-code\">WHERE</span>  clause needed for the join to work correctly.\n    </p> <div class=\"sql-docs-code-block\">SELECT t1.c1, t2.c2 FROM <b>t1, t2</b> WHERE<br/>  <b>t1.id = t2.id AND t1.type_flag = t2.type_flag</b> AND t1.c1 > 100;</div><p><b>Self-joins:</b> </p> <p>\n      Impala can do self-joins, for example to join on two different columns in the same table to represent\n      parent-child relationships or other tree-structured data. There is no explicit syntax for this; just use the\n      same table name for both the left-hand and right-hand table, and assign different table aliases to use when\n      referring to the fully qualified column names:\n    </p> <div class=\"sql-docs-code-block\">-- Combine fields from both parent and child rows.<br/>SELECT lhs.id, rhs.parent, lhs.c1, rhs.c2 FROM tree_data lhs, tree_data rhs WHERE lhs.id = rhs.parent;</div><p><b>Cartesian joins:</b> </p> <p>\n      To avoid producing huge result sets by mistake, Impala does not allow Cartesian joins of the form:\n<div class=\"sql-docs-code-block\">SELECT ... FROM t1 JOIN t2;<br/>SELECT ... FROM t1, t2;</div>\n      If you intend to join the tables based on common values, add <span class=\"sql-docs-inline-code\">ON</span>  or <span class=\"sql-docs-inline-code\">WHERE</span> \n      clauses to compare columns across the tables. If you truly intend to do a Cartesian join, use the\n      <span class=\"sql-docs-inline-code\">CROSS JOIN</span>  keyword as the join operator. The <span class=\"sql-docs-inline-code\">CROSS JOIN</span>  form does not use\n      any <span class=\"sql-docs-inline-code\">ON</span>  clause, because it produces a result set with all combinations of rows from the\n      left-hand and right-hand tables. The result set can still be filtered by subsequent <span class=\"sql-docs-inline-code\">WHERE</span> \n      clauses. For example:\n    </p> <div class=\"sql-docs-code-block\">SELECT ... FROM t1 CROSS JOIN t2;<br/>SELECT ... FROM t1 CROSS JOIN t2 WHERE <span class=\"sql-docs-variable\">tests_on_non_join_columns</span> ;</div><p><b>Inner and outer joins:</b> </p> <p>\n      An inner join is the most common and familiar type: rows in the result set contain the requested columns from\n      the appropriate tables, for all combinations of rows where the join columns of the tables have identical\n      values. If a column with the same name occurs in both tables, use a fully qualified name or a column alias to\n      refer to the column in the select list or other clauses. Impala performs inner joins by default for both\n      SQL-89 and SQL-92 join syntax:\n    </p> <div class=\"sql-docs-code-block\">-- The following 3 forms are all equivalent.<br/>SELECT t1.id, c1, c2 FROM t1, t2 WHERE t1.id = t2.id;<br/>SELECT t1.id, c1, c2 FROM t1 JOIN t2 ON t1.id = t2.id;<br/>SELECT t1.id, c1, c2 FROM t1 INNER JOIN t2 ON t1.id = t2.id;</div><p>\n      An outer join retrieves all rows from the left-hand table, or the right-hand table, or both; wherever there\n      is no matching data in the table on the other side of the join, the corresponding columns in the result set\n      are set to <span class=\"sql-docs-inline-code\">NULL</span> . To perform an outer join, include the <span class=\"sql-docs-inline-code\">OUTER</span>  keyword in the\n      join operator, along with either <span class=\"sql-docs-inline-code\">LEFT</span> , <span class=\"sql-docs-inline-code\">RIGHT</span> , or <span class=\"sql-docs-inline-code\">FULL</span> :\n    </p> <div class=\"sql-docs-code-block\">SELECT * FROM t1 LEFT OUTER JOIN t2 ON t1.id = t2.id;<br/>SELECT * FROM t1 RIGHT OUTER JOIN t2 ON t1.id = t2.id;<br/>SELECT * FROM t1 FULL OUTER JOIN t2 ON t1.id = t2.id;</div><p>\n      For outer joins, Impala requires SQL-92 syntax; that is, the <span class=\"sql-docs-inline-code\">JOIN</span>  keyword instead of\n      comma-separated table names. Impala does not support vendor extensions such as <span class=\"sql-docs-inline-code\">(+)</span>  or\n      <span class=\"sql-docs-inline-code\">*=</span>  notation for doing outer joins with SQL-89 query syntax.\n    </p> <p><b>Equijoins and Non-Equijoins:</b> </p> <p>\n      By default, Impala requires an equality comparison between the left-hand and right-hand tables, either\n      through <span class=\"sql-docs-inline-code\">ON</span> , <span class=\"sql-docs-inline-code\">USING</span> , or <span class=\"sql-docs-inline-code\">WHERE</span>  clauses. These types of\n      queries are classified broadly as equijoins. Inner, outer, full, and semi joins can all be equijoins based on\n      the presence of equality tests between columns in the left-hand and right-hand tables.\n    </p> <p>\n      In Impala 1.2.2 and higher, non-equijoin queries are also possible, with comparisons such as\n      <span class=\"sql-docs-inline-code\">!=</span>  or <span class=\"sql-docs-inline-code\"><</span>  between the join columns. These kinds of queries require care to\n      avoid producing huge result sets that could exceed resource limits. Once you have planned a non-equijoin\n      query that produces a result set of acceptable size, you can code the query using the <span class=\"sql-docs-inline-code\">CROSS\n      JOIN</span>  operator, and add the extra comparisons in the <span class=\"sql-docs-inline-code\">WHERE</span>  clause:\n    </p> <div class=\"sql-docs-code-block\">SELECT * FROM t1 CROSS JOIN t2 WHERE t1.total > t2.maximum_price;</div><p>\n      In Impala 2.3 and higher, additional non-equijoin queries are possible due to the addition\n      of nested loop joins. These queries typically involve <span class=\"sql-docs-inline-code\">SEMI JOIN</span> ,\n      <span class=\"sql-docs-inline-code\">ANTI JOIN</span> , or <span class=\"sql-docs-inline-code\">FULL OUTER JOIN</span>  clauses.\n      Impala sometimes also uses nested loop joins internally when evaluating <span class=\"sql-docs-inline-code\">OUTER JOIN</span> \n      queries involving complex type columns.\n      Query phases involving nested loop joins do not use the spill-to-disk mechanism if they\n      exceed the memory limit. Impala decides internally when to use each join mechanism; you cannot\n      specify any query hint to choose between the nested loop join or the original hash join algorithm.\n    </p> <div class=\"sql-docs-code-block\">SELECT * FROM t1 LEFT OUTER JOIN t2 ON t1.int_col < t2.int_col;</div><p><b>Semi-joins:</b> </p> <p>\n      Semi-joins are a relatively rarely used variation. With the left semi-join, only data from the left-hand\n      table is returned, for rows where there is matching data in the right-hand table, based on comparisons\n      between join columns in <span class=\"sql-docs-inline-code\">ON</span>  or <span class=\"sql-docs-inline-code\">WHERE</span>  clauses. Only one instance of each row\n      from the left-hand table is returned, regardless of how many matching rows exist in the right-hand table.\n      <span class=\"sql-docs-inline-code\">A right semi-join (available in Impala 2.0 and higher) reverses the comparison and returns\n      data from the right-hand table.</span> </p> <div class=\"sql-docs-code-block\">SELECT t1.c1, t1.c2, t1.c2 FROM t1 LEFT SEMI JOIN t2 ON t1.id = t2.id;</div><p><b>Natural joins (not supported):</b> </p> <p>\n      Impala does not support the <span class=\"sql-docs-inline-code\">NATURAL JOIN</span>  operator, again to avoid inconsistent or huge\n      result sets. Natural joins do away with the <span class=\"sql-docs-inline-code\">ON</span>  and <span class=\"sql-docs-inline-code\">USING</span>  clauses, and\n      instead automatically join on all columns with the same names in the left-hand and right-hand tables. This\n      kind of query is not recommended for rapidly evolving data structures such as are typically used in Hadoop.\n      Thus, Impala does not support the <span class=\"sql-docs-inline-code\">NATURAL JOIN</span>  syntax, which can produce different query\n      results as columns are added to or removed from tables.\n    </p> <p>\n      If you do have any queries that use <span class=\"sql-docs-inline-code\">NATURAL JOIN</span> , make sure to rewrite them with explicit\n      <span class=\"sql-docs-inline-code\">USING</span>  clauses, because Impala could interpret the <span class=\"sql-docs-inline-code\">NATURAL</span>  keyword as a\n      table alias:\n    </p> <div class=\"sql-docs-code-block\">-- 'NATURAL' is interpreted as an alias for 't1' and Impala attempts an inner join,<br/>-- resulting in an error because inner joins require explicit comparisons between columns.<br/>SELECT t1.c1, t2.c2 FROM t1 NATURAL JOIN t2;<br/>ERROR: NotImplementedException: Join with 't2' requires at least one conjunctive equality predicate.<br/>  To perform a Cartesian product between two tables, use a CROSS JOIN.<br/><br/>-- If you expect the tables to have identically named columns with matching values,<br/>-- list the corresponding column names in a USING clause.<br/>SELECT t1.c1, t2.c2 FROM t1 JOIN t2 USING (id, type_flag, name, address);</div><p><b>Anti-joins (Impala 2.0 and higher only):</b> </p> <p>\n      Impala supports the <span class=\"sql-docs-inline-code\">LEFT ANTI JOIN</span>  and <span class=\"sql-docs-inline-code\">RIGHT ANTI JOIN</span>  clauses in\n      Impala 2.0 and higher. The <span class=\"sql-docs-inline-code\">LEFT</span>  or <span class=\"sql-docs-inline-code\">RIGHT</span> \n      keyword is required for this kind of join. For <span class=\"sql-docs-inline-code\">LEFT ANTI JOIN</span> , this clause returns those\n      values from the left-hand table that have no matching value in the right-hand table. <span class=\"sql-docs-inline-code\">RIGHT ANTI\n      JOIN</span>  reverses the comparison and returns values from the right-hand table. You can express this\n      negative relationship either through the <span class=\"sql-docs-inline-code\">ANTI JOIN</span>  clause or through a <span class=\"sql-docs-inline-code\">NOT\n      EXISTS</span>  operator with a subquery.\n    </p> <p id=\"../Impala/docs/topics/impala_joins.xml_complex_types_blurb\"><b>Complex type considerations:</b> </p> <p>\n      When referring to a column with a complex type (<span class=\"sql-docs-inline-code\">STRUCT</span> , <span class=\"sql-docs-inline-code\">ARRAY</span> , or <span class=\"sql-docs-inline-code\">MAP</span> )\n      in a query, you use join notation to <q>unpack</q>  the scalar fields of the struct, the elements of the array, or\n      the key-value pairs of the map. (The join notation is not required for aggregation operations, such as\n      <span class=\"sql-docs-inline-code\">COUNT()</span>  or <span class=\"sql-docs-inline-code\">SUM()</span>  for array elements.) Because Impala recognizes which complex type elements are associated with which row\n      of the result set, you use the same syntax as for a cross or cartesian join, without an explicit join condition.\n      See <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_complex_types.xml#complex_types\">Complex Types (Impala 2.3 or higher only)</a> for details about Impala support for complex types.\n    </p> <p id=\"../Impala/docs/topics/impala_joins.xml_usage_notes_blurb\"><b>Usage notes:</b> </p> <p>\n      You typically use join queries in situations like these:\n    </p> <ul><li>\n        When related data arrives from different sources, with each data set physically residing in a separate\n        table. For example, you might have address data from business records that you cross-check against phone\n        listings or census data.\n        <div class=\"sql-docs-note\">\n          Impala can join tables of different file formats, including Impala-managed tables and HBase tables. For\n          example, you might keep small dimension tables in HBase, for convenience of single-row lookups and\n          updates, and for the larger fact tables use Parquet or other binary file format optimized for scan\n          operations. Then, you can issue a join query to cross-reference the fact tables with the dimension\n          tables.\n        </div> </li> <li>\n        When data is normalized, a technique for reducing data duplication by dividing it across multiple tables.\n        This kind of organization is often found in data that comes from traditional relational database systems.\n        For example, instead of repeating some long string such as a customer name in multiple tables, each table\n        might contain a numeric customer ID. Queries that need to display the customer name could <q>join</q>  the\n        table that specifies which customer ID corresponds to which name.\n      </li> <li>\n        When certain columns are rarely needed for queries, so they are moved into separate tables to reduce\n        overhead for common queries. For example, a <span class=\"sql-docs-inline-code\">biography</span>  field might be rarely needed in\n        queries on employee data. Putting that field in a separate table reduces the amount of I/O for common\n        queries on employee addresses or phone numbers. Queries that do need the <span class=\"sql-docs-inline-code\">biography</span>  column\n        can retrieve it by performing a join with that separate table.\n      </li> <li>\n        In Impala 2.3 or higher, when referring to complex type columns in queries.\n        See <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_complex_types.xml#complex_types\">Complex Types (Impala 2.3 or higher only)</a> for details.\n      </li> </ul> <p>\n      When comparing columns with the same names in <span class=\"sql-docs-inline-code\">ON</span>  or <span class=\"sql-docs-inline-code\">WHERE</span>  clauses, use the\n      fully qualified names such as <span class=\"sql-docs-inline-code\"><span class=\"sql-docs-variable\">db_name</span> .<span class=\"sql-docs-variable\">table_name</span> </span> , or\n      assign table aliases, column aliases, or both to make the code more compact and understandable:\n    </p> <div class=\"sql-docs-code-block\">select t1.c1 as first_id, t2.c2 as second_id from<br/>  t1 join t2 on first_id = second_id;<br/><br/>select fact.custno, dimension.custno from<br/>  customer_data as fact join customer_address as dimension<br/>  using (custno)</div><div class=\"sql-docs-note\"><p>\n        Performance for join queries is a crucial aspect for Impala, because complex join queries are\n        resource-intensive operations. An efficient join query produces much less network traffic and CPU overhead\n        than an inefficient one. For best results:\n      </p> <ul><li>\n          Make sure that both <span>table and column statistics</span> are\n          available for all the tables involved in a join query, and especially for the columns referenced in any\n          join conditions. Impala uses the statistics to automatically deduce an efficient join order.\n          Use <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_show.xml#show\">SHOW TABLE STATS table_name and\n          SHOW COLUMN STATS table_name</a> to check if statistics are\n          already present. Issue the <span class=\"sql-docs-inline-code\">COMPUTE STATS <span class=\"sql-docs-variable\">table_name</span> </span>  for a nonpartitioned table,\n          or (in Impala 2.1.0 and higher) <span class=\"sql-docs-inline-code\">COMPUTE INCREMENTAL STATS <span class=\"sql-docs-variable\">table_name</span> </span> \n          for a partitioned table, to collect the initial statistics at both the table and column levels, and to keep the\n          statistics up to date after any substantial <span class=\"sql-docs-inline-code\">INSERT</span>  or <span class=\"sql-docs-inline-code\">LOAD DATA</span>  operations.\n        </li> <li>\n          If table or column statistics are not available, join the largest table first. You can check the\n          existence of statistics with the <span class=\"sql-docs-inline-code\">SHOW TABLE STATS <span class=\"sql-docs-variable\">table_name</span> </span>  and\n          <span class=\"sql-docs-inline-code\">SHOW COLUMN STATS <span class=\"sql-docs-variable\">table_name</span> </span>  statements.\n        </li> <li>\n          If table or column statistics are not available, join subsequent tables according to which table has the\n          most selective filter, based on overall size and <span class=\"sql-docs-inline-code\">WHERE</span>  clauses. Joining the table with\n          the most selective filter results in the fewest number of rows being returned.\n        </li> </ul> <p>\n        For more information and examples of performance for join queries, see\n        <span>perf joins</span>.\n      </p> </div> <p>\n      To control the result set from a join query, include the names of corresponding column names in both tables\n      in an <span class=\"sql-docs-inline-code\">ON</span>  or <span class=\"sql-docs-inline-code\">USING</span>  clause, or by coding equality comparisons for those\n      columns in the <span class=\"sql-docs-inline-code\">WHERE</span>  clause.\n    </p> <div class=\"sql-docs-code-block\">[localhost:21000] > select c_last_name, ca_city from customer join customer_address where c_customer_sk = ca_address_sk;<br/>+-------------+-----------------+<br/>| c_last_name | ca_city         |<br/>+-------------+-----------------+<br/>| Lewis       | Fairfield       |<br/>| Moses       | Fairview        |<br/>| Hamilton    | Pleasant Valley |<br/>| White       | Oak Ridge       |<br/>| Moran       | Glendale        |<br/>...<br/>| Richards    | Lakewood         |<br/>| Day         | Lebanon          |<br/>| Painter     | Oak Hill         |<br/>| Bentley     | Greenfield       |<br/>| Jones       | Stringtown       |<br/>+-------------+------------------+<br/>Returned 50000 row(s) in 9.82s</div><p>\n      One potential downside of joins is the possibility of excess resource usage in poorly constructed queries.\n      Impala imposes restrictions on join queries to guard against such issues. To minimize the chance of runaway\n      queries on large data sets, Impala requires every join query to contain at least one equality predicate\n      between the columns of the various tables. For example, if <span class=\"sql-docs-inline-code\">T1</span>  contains 1000 rows and\n      <span class=\"sql-docs-inline-code\">T2</span>  contains 1,000,000 rows, a query <span class=\"sql-docs-inline-code\">SELECT <span class=\"sql-docs-variable\">columns</span>  FROM t1 JOIN\n      t2</span>  could return up to 1 billion rows (1000 * 1,000,000); Impala requires that the query include a\n      clause such as <span class=\"sql-docs-inline-code\">ON t1.c1 = t2.c2</span>  or <span class=\"sql-docs-inline-code\">WHERE t1.c1 = t2.c2</span> .\n    </p> <p>\n      Because even with equality clauses, the result set can still be large, as we saw in the previous example, you\n      might use a <span class=\"sql-docs-inline-code\">LIMIT</span>  clause to return a subset of the results:\n    </p> <div class=\"sql-docs-code-block\">[localhost:21000] > select c_last_name, ca_city from customer, customer_address where c_customer_sk = ca_address_sk limit 10;<br/>+-------------+-----------------+<br/>| c_last_name | ca_city         |<br/>+-------------+-----------------+<br/>| Lewis       | Fairfield       |<br/>| Moses       | Fairview        |<br/>| Hamilton    | Pleasant Valley |<br/>| White       | Oak Ridge       |<br/>| Moran       | Glendale        |<br/>| Sharp       | Lakeview        |<br/>| Wiles       | Farmington      |<br/>| Shipman     | Union           |<br/>| Gilbert     | New Hope        |<br/>| Brunson     | Martinsville    |<br/>+-------------+-----------------+<br/>Returned 10 row(s) in 0.63s</div><p>\n      Or you might use additional comparison operators or aggregation functions to condense a large result set into\n      a smaller set of values:\n    </p> <div class=\"sql-docs-code-block\">[localhost:21000] > -- Find the names of customers who live in one particular town.<br/>[localhost:21000] > select distinct c_last_name from customer, customer_address where<br/>  c_customer_sk = ca_address_sk<br/>  and ca_city = \"Green Acres\";<br/>+---------------+<br/>| c_last_name   |<br/>+---------------+<br/>| Hensley       |<br/>| Pearson       |<br/>| Mayer         |<br/>| Montgomery    |<br/>| Ricks         |<br/>...<br/>| Barrett       |<br/>| Price         |<br/>| Hill          |<br/>| Hansen        |<br/>| Meeks         |<br/>+---------------+<br/>Returned 332 row(s) in 0.97s<br/><br/>[localhost:21000] > -- See how many different customers in this town have names starting with \"A\".<br/>[localhost:21000] > select count(distinct c_last_name) from customer, customer_address where<br/>  c_customer_sk = ca_address_sk<br/>  and ca_city = \"Green Acres\"<br/>  and substr(c_last_name,1,1) = \"A\";<br/>+-----------------------------+<br/>| count(distinct c_last_name) |<br/>+-----------------------------+<br/>| 12                          |<br/>+-----------------------------+<br/>Returned 1 row(s) in 1.00s</div><p>\n      Because a join query can involve reading large amounts of data from disk, sending large amounts of data\n      across the network, and loading large amounts of data into memory to do the comparisons and filtering, you\n      might do benchmarking, performance analysis, and query tuning to find the most efficient join queries for\n      your data set, hardware capacity, network configuration, and cluster workload.\n    </p> <p>\n      The two categories of joins in Impala are known as <b>partitioned joins</b>  and <b>broadcast joins</b> . If\n      inaccurate table or column statistics, or some quirk of the data distribution, causes Impala to choose the\n      wrong mechanism for a particular join, consider using query hints as a temporary workaround. For details, see\n      <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_hints.xml#hints\">Optimizer Hints</a>.\n    </p> <p><b>Handling NULLs in Join Columns:</b> </p> <p>\n      By default, join key columns do not match if either one contains a <span class=\"sql-docs-inline-code\">NULL</span>  value.\n      To treat such columns as equal if both contain <span class=\"sql-docs-inline-code\">NULL</span> , you can use an expression\n      such as <span class=\"sql-docs-inline-code\">A = B OR (A IS NULL AND B IS NULL)</span> .\n      In Impala 2.5 and higher, the <span class=\"sql-docs-inline-code\"><=></span>  operator (shorthand for\n      <span class=\"sql-docs-inline-code\">IS NOT DISTINCT FROM</span> ) performs the same comparison in a concise and efficient form.\n      The <span class=\"sql-docs-inline-code\"><=></span>  operator is more efficient in for comparing join keys in a <span class=\"sql-docs-inline-code\">NULL</span> -safe\n      manner, because the operator can use a hash join while the <span class=\"sql-docs-inline-code\">OR</span>  expression cannot.\n    </p> <p id=\"../Impala/docs/topics/impala_joins.xml_example_blurb\"><b>Examples:</b> </p> <p>\n      The following examples refer to these simple tables containing small sets of integers:\n<div class=\"sql-docs-code-block\">[localhost:21000] > create table t1 (x int);<br/>[localhost:21000] > insert into t1 values (1), (2), (3), (4), (5), (6);<br/><br/>[localhost:21000] > create table t2 (y int);<br/>[localhost:21000] > insert into t2 values (2), (4), (6);<br/><br/>[localhost:21000] > create table t3 (z int);<br/>[localhost:21000] > insert into t3 values (1), (3), (5);<br/></div></p> <p>\n      The following example demonstrates an anti-join, returning the values from <span class=\"sql-docs-inline-code\">T1</span>  that do not\n      exist in <span class=\"sql-docs-inline-code\">T2</span>  (in this case, the odd numbers 1, 3, and 5):\n    </p> <div class=\"sql-docs-code-block\">[localhost:21000] > select x from t1 left anti join t2 on (t1.x = t2.y);<br/>+---+<br/>| x |<br/>+---+<br/>| 1 |<br/>| 3 |<br/>| 5 |<br/>+---+<br/></div><p id=\"../Impala/docs/topics/impala_joins.xml_related_info\"><b>Related information:</b> </p> <p>\n      See these tutorials for examples of different kinds of joins:\n    </p> <ul><li><span>tut cross join</span></li> </ul> </div> ","title":"Joins in Impala SELECT Statements"}