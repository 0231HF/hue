{"body":"<div><p>\n      A single precision floating-point data type used in <span class=\"sql-docs-inline-code\">CREATE TABLE</span>  and <span class=\"sql-docs-inline-code\">ALTER\n      TABLE</span>  statements.\n    </p> <p id=\"../Impala/docs/topics/impala_float.xml_syntax_blurb\"><b>Syntax:</b> </p> <p>\n      In the column definition of a <span class=\"sql-docs-inline-code\">CREATE TABLE</span>  statement:\n    </p> <div class=\"sql-docs-code-block\"><span class=\"sql-docs-variable\">column_name</span> FLOAT</div><p><b>Range:</b>  1.40129846432481707e-45 .. 3.40282346638528860e+38, positive or negative\n    </p> <p><b>Precision:</b>  6 to 9 significant digits, depending on usage. The number of significant digits does\n      not depend on the position of the decimal point.\n    </p> <p><b>Representation:</b>  The values are stored in 4 bytes, using\n      <a target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Single-precision_floating-point_format\">IEEE 754 Single Precision Binary Floating Point</a> format.\n    </p> <p><b>Conversions:</b>  Impala automatically converts <span class=\"sql-docs-inline-code\">FLOAT</span>  to more precise\n      <span class=\"sql-docs-inline-code\">DOUBLE</span>  values, but not the other way around. You can use <span class=\"sql-docs-inline-code\">CAST()</span>  to convert\n      <span class=\"sql-docs-inline-code\">FLOAT</span>  values to <span class=\"sql-docs-inline-code\">TINYINT</span> , <span class=\"sql-docs-inline-code\">SMALLINT</span> , <span class=\"sql-docs-inline-code\">INT</span> ,\n      <span class=\"sql-docs-inline-code\">BIGINT</span> , <span class=\"sql-docs-inline-code\">STRING</span> , <span class=\"sql-docs-inline-code\">TIMESTAMP</span> , or <span class=\"sql-docs-inline-code\">BOOLEAN</span> .\n      You can use exponential notation in <span class=\"sql-docs-inline-code\">FLOAT</span>  literals or when casting from\n      <span class=\"sql-docs-inline-code\">STRING</span> , for example <span class=\"sql-docs-inline-code\">1.0e6</span>  to represent one million.\n      <span id=\"../Impala/docs/topics/impala_float.xml_cast_int_to_timestamp\" class=\"sql-docs-inline-code\">\n          Casting an integer or floating-point value <span class=\"sql-docs-inline-code\">N</span>  to\n        <span class=\"sql-docs-inline-code\">TIMESTAMP</span>  produces a value that is <span class=\"sql-docs-inline-code\">N</span>  seconds past the start of the epoch\n        date (January 1, 1970). By default, the result value represents a date and time in the UTC time zone.\n        If the setting <span class=\"sql-docs-inline-code\">--use_local_tz_for_unix_timestamp_conversions=true</span>  is in effect,\n        the resulting <span class=\"sql-docs-inline-code\">TIMESTAMP</span>  represents a date and time in the local time zone.\n        </span> </p> <p id=\"../Impala/docs/topics/impala_float.xml_usage_notes_blurb\"><b>Usage notes:</b> </p> <p id=\"../Impala/docs/topics/impala_float.xml_how_impala_handles_nan_values\">\n        Impala does not evaluate NaN (not a number) as equal to any other numeric values,\n        including other NaN values. For example, the following statement, which evaluates equality\n        between two NaN values, returns <span class=\"sql-docs-inline-code\">false</span> :\n      </p> <div class=\"sql-docs-code-block\">SELECT CAST('nan' AS FLOAT)=CAST('nan' AS FLOAT);<br/></div><p id=\"../Impala/docs/topics/impala_float.xml_example_blurb\"><b>Examples:</b> </p> <div class=\"sql-docs-code-block\">CREATE TABLE t1 (x FLOAT);<br/>SELECT CAST(1000.5 AS FLOAT);<br/></div><p id=\"../Impala/docs/topics/impala_float.xml_partitioning_imprecise\"><b>Partitioning:</b>  Because fractional values of this type are not always represented precisely, when this\n        type is used for a partition key column, the underlying HDFS directories might not be named exactly as you\n        expect. Prefer to partition on a <span class=\"sql-docs-inline-code\">DECIMAL</span>  column instead.\n      </p> <p id=\"../Impala/docs/topics/impala_float.xml_hbase_ok\"><b>HBase considerations:</b>  This data type is fully compatible with HBase tables.\n      </p> <p id=\"../Impala/docs/topics/impala_float.xml_parquet_ok\"><b>Parquet considerations:</b>  This type is fully compatible with Parquet tables.\n      </p> <p id=\"../Impala/docs/topics/impala_float.xml_text_bulky\"><b>Text table considerations:</b>  Values of this type are potentially larger in text tables than in tables\n        using Parquet or other binary formats.\n      </p> <p id=\"../Impala/docs/topics/impala_float.xml_internals_4_bytes\"><b>Internal details:</b>  Represented in memory as a 4-byte value.\n      </p> <p id=\"../Impala/docs/topics/impala_float.xml_column_stats_constant\"><b>Column statistics considerations:</b>  Because this type has a fixed size, the maximum and average size\n        fields are always filled in for column statistics, even before you run the <span class=\"sql-docs-inline-code\">COMPUTE STATS</span> \n        statement.\n      </p> <p id=\"../Impala/docs/topics/impala_float.xml_restrictions_blurb\"><b>Restrictions:</b> </p> <p id=\"../Impala/docs/topics/impala_float.xml_sum_double\">\n        Due to the way arithmetic on <span class=\"sql-docs-inline-code\">FLOAT</span>  and <span class=\"sql-docs-inline-code\">DOUBLE</span>  columns uses\n        high-performance hardware instructions, and distributed queries can perform these operations in different\n        order for each query, results can vary slightly for aggregate function calls such as <span class=\"sql-docs-inline-code\">SUM()</span> \n        and <span class=\"sql-docs-inline-code\">AVG()</span>  for <span class=\"sql-docs-inline-code\">FLOAT</span>  and <span class=\"sql-docs-inline-code\">DOUBLE</span>  columns, particularly on\n        large data sets where millions or billions of values are summed or averaged. For perfect consistency and\n        repeatability, use the <span class=\"sql-docs-inline-code\">DECIMAL</span>  data type for such operations instead of\n        <span class=\"sql-docs-inline-code\">FLOAT</span>  or <span class=\"sql-docs-inline-code\">DOUBLE</span> .\n      </p> <p id=\"../Impala/docs/topics/impala_float.xml_float_double_decimal_caveat\">\n        The inability to exactly represent certain floating-point values means that\n        <span class=\"sql-docs-inline-code\">DECIMAL</span>  is sometimes a better choice than <span class=\"sql-docs-inline-code\">DOUBLE</span> \n        or <span class=\"sql-docs-inline-code\">FLOAT</span>  when precision is critical, particularly when\n        transferring data from other database systems that use different representations\n        or file formats.\n      </p> <p id=\"../Impala/docs/topics/impala_float.xml_kudu_blurb\"><b>Kudu considerations:</b> </p> <p id=\"../Impala/docs/topics/impala_float.xml_kudu_non_pk_data_type\">\n        Currently, the data types <span class=\"sql-docs-inline-code\">BOOLEAN</span> , <span class=\"sql-docs-inline-code\">FLOAT</span> ,\n        and <span class=\"sql-docs-inline-code\">DOUBLE</span>  cannot be used for primary key columns in Kudu tables.\n      </p> <p id=\"../Impala/docs/topics/impala_float.xml_related_info\"><b>Related information:</b> </p> <p><a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_literals.xml#numeric_literals\"><h4>Numeric Literals</h4> </a>, <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_math_functions.xml#math_functions\">Impala Mathematical Functions</a>,\n      <a href=\"javascript: void(0);\" class=\"lang-ref-link\" data-target=\"topics/impala_double.xml#double\">DOUBLE Data Type</a></p> </div> ","title":"FLOAT Data Type"}